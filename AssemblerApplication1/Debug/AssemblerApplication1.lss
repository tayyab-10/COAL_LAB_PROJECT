
AVRASM ver. 2.2.8  D:\AssemblerApplication1\AssemblerApplication1\main.asm Thu Jan 04 13:45:26 2024

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328Pdef.inc'
D:\AssemblerApplication1\AssemblerApplication1\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pdef.inc'
D:\AssemblerApplication1\AssemblerApplication1\main.asm(2): Including file 'D:\AssemblerApplication1\AssemblerApplication1\delayMacros.inc'
D:\AssemblerApplication1\AssemblerApplication1\main.asm(3): Including file 'D:\AssemblerApplication1\AssemblerApplication1\lcd_Macros.inc'
D:\AssemblerApplication1\AssemblerApplication1\main.asm(4): Including file 'D:\AssemblerApplication1\AssemblerApplication1\UART_Macros.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328Pdef.inc'
D:\AssemblerApplication1\AssemblerApplication1\main.asm(1): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m328pdef.inc'
D:\AssemblerApplication1\AssemblerApplication1\main.asm(2): Including file 'D:\AssemblerApplication1\AssemblerApplication1\delayMacros.inc'
D:\AssemblerApplication1\AssemblerApplication1\main.asm(3): Including file 'D:\AssemblerApplication1\AssemblerApplication1\lcd_Macros.inc'
D:\AssemblerApplication1\AssemblerApplication1\main.asm(4): Including file 'D:\AssemblerApplication1\AssemblerApplication1\UART_Macros.inc'
                                 
                                 .include "m328pdef.inc" 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m328Pdef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega328P
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328P
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PDEF_INC_
                                 #define _M328PDEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega328P
                                 #pragma AVRPART ADMIN PART_NAME ATmega328P
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x0f
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1B	= 6	; 
                                 .equ	FOC1A	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register
                                 .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
                                 .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
                                 .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; SPMCSR - Store Program Memory Control and Status Register
                                 .equ    SELFPRGEN = 0; Added for backwards compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read-While-Write section read enable
                                 .equ    SIGRD   = 5 ; Signature Row Read
                                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; 
                                 .equ	IVSEL	= 1	; 
                                 .equ	PUD	= 4	; 
                                 .equ	BODSE	= 5	; BOD Sleep Enable
                                 .equ	BODS	= 6	; BOD Sleep
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	EXTREF	= EXTRF	; For compatibility
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                                 
                                 ; GPIOR2 - General Purpose I/O Register 2
                                 .equ	GPIOR20	= 0	; 
                                 .equ	GPIOR21	= 1	; 
                                 .equ	GPIOR22	= 2	; 
                                 .equ	GPIOR23	= 3	; 
                                 .equ	GPIOR24	= 4	; 
                                 .equ	GPIOR25	= 5	; 
                                 .equ	GPIOR26	= 6	; 
                                 .equ	GPIOR27	= 7	; 
                                 
                                 ; GPIOR1 - General Purpose I/O Register 1
                                 .equ	GPIOR10	= 0	; 
                                 .equ	GPIOR11	= 1	; 
                                 .equ	GPIOR12	= 2	; 
                                 .equ	GPIOR13	= 3	; 
                                 .equ	GPIOR14	= 4	; 
                                 .equ	GPIOR15	= 5	; 
                                 .equ	GPIOR16	= 6	; 
                                 .equ	GPIOR17	= 7	; 
                                 
                                 ; GPIOR0 - General Purpose I/O Register 0
                                 .equ	GPIOR00	= 0	; 
                                 .equ	GPIOR01	= 1	; 
                                 .equ	GPIOR02	= 2	; 
                                 .equ	GPIOR03	= 3	; 
                                 .equ	GPIOR04	= 4	; 
                                 .equ	GPIOR05	= 5	; 
                                 .equ	GPIOR06	= 6	; 
                                 .equ	GPIOR07	= 7	; 
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEARH - EEPROM Address Register High Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select reset vector
                                 .equ	BOOTSZ0	= 1	; Select boot size
                                 .equ	BOOTSZ1	= 2	; Select boot size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog Timer Always On
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	DWEN	= 6	; debugWIRE Enable
                                 .equ	RSTDISBL	= 7	; External reset disable
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2048
                                 .equ	RAMEND	= 0x08ff
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
                                 .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
                                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
                                 .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
                                 .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
                                 .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
                                 .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXCaddr	= 0x0024	; USART Rx Complete
                                 .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
                                 .equ	UTXCaddr	= 0x0028	; USART Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 52	; size in words
                                 
                                 #endif  /* _M328PDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m328Pdef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega328P
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega328P
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M328PDEF_INC_
                                 #endif  /* _M328PDEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 .include "delayMacros.inc" 
                                 
                                 .macro delay
                                 push r18
                                 push r24
                                 push r25
                                 ldi r18,@0/10
                                 L1:
                                 ldi r24,LOW(39998) ; intialize inner loop count in inner
                                 ldi r25,HIGH(39998) ; loop high and low registers
                                 L2:
                                 sbiw r24,1 ; decrement inner loop registers
                                 brne L2 ; branch to L2 if iLoop registers != 0
                                 dec r18 ; decrement outer loop register
                                 brne L1 ; branch to L1 if outer loop register != 0
                                 nop ; no operation
                                 pop r25
                                 pop r24
                                 pop r18
                                 .endmacro
                                 
                                 
                                 ; ***************************************************************************
                                 ; *		Macro written by:													*
                                 ; *			Syed Tehseen ul Hasan Shah										*
                                 ; *			Lecturer, University of Engineering and Technology Lahore.		*
                                 ; *			24-December-2023												*
                                 .include "lcd_Macros.inc" 
                                 
                                 
                                 ; [List of all the available macros in this file]
                                 ;	LCD_init
                                 ;	LCD_backlight_OFF
                                 ;	LCD_backlight_ON
                                 ;	LCD_send_a_command
                                 ;	LCD_send_a_character
                                 ;	LCD_send_a_register
                                 ;	LCD_send_a_string
                                 ;	LCD_LCD_clear
                                 ;	LCD_LCD_home
                                 ;	div
                                 
                                 
                                 ;Data Pin Connections for 16x2 LCD
                                 ; [LCD pins]          [Arduino UNO Pins]
                                 ;   RS   ---------------  8 (PB0)
                                 ;   E    ---------------  9 (PB1)
                                 ;   D4   ---------------  4 (PD4)
                                 ;   D5   ---------------  5 (PD5)
                                 ;   D6   ---------------  6 (PD6)
                                 ;   D7   ---------------  7 (PD7)
                                 ;   A   ----------------  13 (PB5)	; Anode pin of LCD Backlight LED
                                 
                                 
                                 ; Macro to initilize the 16x2 LCD
                                 .macro LCD_init
                                 	; Setting pins to Output for LCD
                                 	sbi DDRD,PD4 ; D4
                                 	sbi DDRD,PD5 ; D5
                                 	sbi DDRD,PD6 ; D6
                                 	sbi DDRD,PD7 ; D7
                                 	;Setting LCD Mode selection pins
                                 	sbi DDRB,PB0 ; RS pin of LCD
                                 	sbi DDRB,PB1 ; E pin of LCD
                                 	;Setting LCD Backlight pin
                                 	sbi DDRB,PB5 ; LCD Backlight control pin (BLA or A pin of LCD)
                                 
                                 	; SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
                                 	; according to datasheet, we need at least 40 ms after power rises above 2.7 V
                                 	; before sending commands. Arduino can turn on way before 4.5 V so we'll wait 50ms
                                 	delay 50
                                 	
                                 	; Now we pull both RS and E pins LOW to begin commands
                                 	cbi PORTB, PB0 ; RS pin of LCD
                                 	cbi PORTB, PB1 ; E pin of LCD
                                 
                                 	; put the LCD into 4 bit or 8 bit mode
                                 	; this is according to the Hitachi HD44780 datasheet
                                 	; figure 24, pg 46
                                 	
                                 	; we start in 8bit mode, try to set 4 bit mode
                                 	LCD_send_a_command 0x03
                                 	delay 5	; wait min 4.1ms
                                 
                                 	; second try
                                 	LCD_send_a_command 0x03
                                 	delay 5	; wait min 4.1ms
                                 		
                                 	; third go!
                                 	LCD_send_a_command 0x03
                                 	delay 1
                                 	
                                 	; finally, set to 4-bit interface
                                 	LCD_send_a_command 0x02
                                 
                                 	; finally, set # lines, font size, etc.
                                 	LCD_send_a_command 0x28
                                 
                                 	; turn the display on with no cursor or blinking default
                                 	LCD_send_a_command 0x0C
                                 	
                                 	; clear it off
                                 	LCD_clear
                                 
                                 	; Initialize to default text direction
                                 	LCD_send_a_command 0x06
                                 .endmacro
                                 
                                 ; Macro to clear the LCD
                                 .macro LCD_clear
                                 	LCD_send_a_command 0x01
                                 	delay 10  ; this command takes a long time!
                                 .endmacro
                                 
                                 ; Macro to set LCD cursor position to zero
                                 .macro LCD_home
                                 	LCD_send_a_command 0x02
                                 	delay 10  ; this command takes a long time!
                                 .endmacro
                                 
                                 ; Macro to Turn OFF the LCD Backlight
                                 .macro LCD_backlight_OFF
                                 	cbi PORTB,PB5 ; Backlight OFF
                                 .endmacro
                                 
                                 ; Macro to Turn ON the LCD Backlight
                                 .macro LCD_backlight_ON
                                 	sbi PORTB,PB5 ; Backlight ON
                                 .endmacro
                                 
                                 ; Macro to send a command to control the LCD
                                 ; Usage Example: LCD_send_a_command 0x01
                                 ; all the supported commands are writtern at the end of this file
                                 .macro LCD_send_a_command
                                 	PUSH r16
                                 	LDI r16,@0			; receives the command
                                 	; Clear the pins
                                 	CBI PORTD, PD7         ; Clear PD7
                                 	CBI PORTD, PD6         ; Clear PD6
                                 	CBI PORTD, PD5         ; Clear PD5
                                 	CBI PORTD, PD4         ; Clear PD4
                                 	CBI PORTB, PB0         ; Set RS pin to LOW (set LCD mode to "Command Mode")
                                 	; Send the upper 4 bits of the Command to LCD
                                 	SBRC r16, 7            ; Check the MSB (7th bit)
                                 	SBI PORTD, PD7         ; Set PD7 according to the command bit
                                 	SBRC r16, 6            ; Check the 6th bit
                                 	SBI PORTD, PD6         ; Set PD6 according to the command bit
                                 	SBRC r16, 5            ; Check the 5th bit
                                 	SBI PORTD, PD5         ; Set PD5 according to the command bit
                                 	SBRC r16, 4            ; Check the 4th bit
                                 	SBI PORTD, PD4         ; Set PD4 according to the command bit
                                 
                                 	SBI PORTB, PB1         ; Set E pin to HIGH (set LCD to receive the command)
                                 	delay 10
                                 	CBI PORTB, PB1         ; Set E pin to LOW (set LCD to process the command)
                                 
                                 	; Clear the pins
                                 	CBI PORTD, PD7         ; Clear PD7
                                 	CBI PORTD, PD6         ; Clear PD6
                                 	CBI PORTD, PD5         ; Clear PD5
                                 	CBI PORTD, PD4         ; Clear PD4
                                 
                                 	; Send the lower 4 bits of the Command to LCD
                                 	SBRC r16, 3            ; Check the 3rd bit
                                 	SBI PORTD, PD7         ; Set PD7 according to the command bit
                                 	SBRC r16, 2            ; Check the 2nd bit
                                 	SBI PORTD, PD6         ; Set PD6 according to the command bit
                                 	SBRC r16, 1            ; Check the 1st bit
                                 	SBI PORTD, PD5         ; Set PD5 according to the command bit
                                 	SBRC r16, 0            ; Check the 0th bit
                                 	SBI PORTD, PD4         ; Set PD4 according to the command bit
                                 
                                 	SBI PORTB, PB1         ; Set E pin to HIGH (set LCD to receive the command)
                                 	delay 10
                                 	CBI PORTB, PB1         ; Set E pin to LOW (set LCD to process the command)
                                 
                                 	; Clear the pins
                                 	CBI PORTD, PD7         ; Clear PD7
                                 	CBI PORTD, PD6         ; Clear PD6
                                 	CBI PORTD, PD5         ; Clear PD5
                                 	CBI PORTD, PD4         ; Clear PD4
                                 	
                                 	POP r16
                                 .endmacro
                                 
                                 ; Macro to send a single character to display on the LCD
                                 ; Usage Example: LCD_send_a_character 'A'
                                 .macro LCD_send_a_character
                                 	PUSH r16
                                 	LDI r16,@0			; receives the character
                                 	; Clear the pins
                                 	CBI PORTD, PD7         ; Clear PD7
                                 	CBI PORTD, PD6         ; Clear PD6
                                 	CBI PORTD, PD5         ; Clear PD5
                                 	CBI PORTD, PD4         ; Clear PD4
                                 	SBI PORTB, PB0         ; Set RS pin to HIGH (set LCD mode to "Data Mode")
                                 	; Send the upper 4 bits of the Character to LCD
                                 	SBRC r16, 7            ; Check the MSB (7th bit)
                                 	SBI PORTD, PD7         ; Set PD7 according to the data bit
                                 	SBRC r16, 6            ; Check the 6th bit
                                 	SBI PORTD, PD6         ; Set PD6 according to the data bit
                                 	SBRC r16, 5            ; Check the 5th bit
                                 	SBI PORTD, PD5         ; Set PD5 according to the data bit
                                 	SBRC r16, 4            ; Check the 4th bit
                                 	SBI PORTD, PD4         ; Set PD4 according to the data bit
                                 
                                 	SBI PORTB, PB1         ; Set E pin to HIGH (set LCD to receive the data)
                                 	delay 10
                                 	CBI PORTB, PB1         ; Set E pin to LOW (set LCD to process the data)
                                 
                                 	; Clear the pins
                                 	CBI PORTD, PD7         ; Clear PD7
                                 	CBI PORTD, PD6         ; Clear PD6
                                 	CBI PORTD, PD5         ; Clear PD5
                                 	CBI PORTD, PD4         ; Clear PD4
                                 
                                 	; Send the lower 4 bits of the Character to LCD
                                 	SBRC r16, 3            ; Check the 3rd bit
                                 	SBI PORTD, PD7         ; Set PD7 according to the data bit
                                 	SBRC r16, 2            ; Check the 2nd bit
                                 	SBI PORTD, PD6         ; Set PD6 according to the data bit
                                 	SBRC r16, 1            ; Check the 1st bit
                                 	SBI PORTD, PD5         ; Set PD5 according to the data bit
                                 	SBRC r16, 0            ; Check the 0th bit
                                 	SBI PORTD, PD4         ; Set PD4 according to the data bit
                                 
                                 	SBI PORTB, PB1         ; Set E pin to HIGH (set LCD to receive the data)
                                 	delay 10
                                 	CBI PORTB, PB1         ; Set E pin to LOW (set LCD to process the data)
                                 
                                 	; Clear the pins
                                 	CBI PORTD, PD7         ; Clear PD7
                                 	CBI PORTD, PD6         ; Clear PD6
                                 	CBI PORTD, PD5         ; Clear PD5
                                 	CBI PORTD, PD4         ; Clear PD4
                                 	
                                 	POP r16
                                 .endmacro
                                 
                                 
                                 ; Macro to send a register to display its integer value on the LCD
                                 ; Usage Example: LCD_send_a_register r16
                                 .macro LCD_send_a_register
                                 	PUSH r15
                                 	PUSH r16
                                 	PUSH r17
                                 	PUSH r18
                                 	PUSH r19
                                 	PUSH r28
                                 	PUSH r29
                                 	PUSH r30
                                 
                                 	MOV r16,@0			; receives the register
                                 	mov r19, r16		; take backup of origional value to r19
                                 	
                                 	; Convert the 8-bit (0-255) integer to ASCII encoded integer
                                 	; by simply spliting it and adding 48 to its individual digits then
                                 	; print those individual digits to LCD
                                 
                                 	; Split the integer into individual digits
                                 	ldi r28, 0          ; Initialize r28 (ones place) to 0
                                 	ldi r29, 0          ; Initialize r29 (tens place) to 0
                                 	ldi r30, 0          ; Initialize r30 (hundreds place) to 0
                                 
                                 	; Ones place
                                 	ldi r17, 10         ; Load divisor (10) into r17
                                 	div					; Divide r16 by 10, result in r16, remainder in r15
                                 	mov r28, r15        ; Move remainder (ones place) to r28
                                 
                                 	; Tens place
                                 	ldi r17, 10         ; Load divisor (10) into r17
                                 	div			        ; Divide r16 by 10, result in r16, remainder in r15
                                 	mov r29, r15        ; Move remainder (tens place) to r29
                                 
                                 	; Hundreds place
                                 	ldi r17, 10         ; Load divisor (10) into r17
                                 	div			        ; Divide r16 by 10, result in r16, remainder in r15
                                 	mov r30, r15        ; Move remainder (hundreds place) to r30
                                 
                                 	; Now r28 has the ones place, r29 has the tens place, and r30 has the hundreds place
                                 	; e.g. integer 235 will split into --> r30=2 , r29=3 , r28=5
                                 
                                 	LDI r18, 0	; counter for the loop logic
                                 	LDI r17, 48 ; 48 will be added to each digit to encode it to ASCII integer
                                 	
                                 	; loop to send all 3 register r30, r29 and r28 to LCD one by one
                                 	LCD_send_a_register_writing:
                                 	cpi r18, 0
                                 	BREQ LCD_send_a_register_writing_L1
                                 	cpi r18, 1
                                 	BREQ LCD_send_a_register_writing_L2
                                 	cpi r18, 2
                                 	BREQ LCD_send_a_register_writing_L3
                                 	rjmp LCD_send_a_register_writing_end
                                 
                                 	; sending r30 to LCD
                                 	LCD_send_a_register_writing_L1:
                                 	CPI r19, 100
                                 	BRLO LCD_send_a_register_writing_skip_temp	; if the origional number was from 0 to 99, then skip sending r30 to LCD
                                 	add r30, r17
                                 	mov r16, r30
                                 	rjmp LCD_send_a_register_writing_start
                                 
                                 	; sending r29 to LCD
                                 	LCD_send_a_register_writing_L2:
                                 	CPI r19, 10
                                 	BRLO LCD_send_a_register_writing_skip_temp	; if the origional number was from 0 to 9, then skip sending r29 as well
                                 	add r29, r17
                                 	mov r16, r29
                                 	rjmp LCD_send_a_register_writing_start
                                 
                                 	; sending r28 to LCD
                                 	LCD_send_a_register_writing_L3:
                                 	add r28, r17
                                 	mov r16, r28
                                 	rjmp LCD_send_a_register_writing_start
                                 
                                 	LCD_send_a_register_writing_start:
                                 	; Clear the pins
                                 	CBI PORTD, PD7         ; Clear PD7
                                 	CBI PORTD, PD6         ; Clear PD6
                                 	CBI PORTD, PD5         ; Clear PD5
                                 	CBI PORTD, PD4         ; Clear PD4
                                 	SBI PORTB, PB0         ; Set RS pin to HIGH (set LCD mode to "Data Mode")
                                 	; Send the upper 4 bits of the Register to LCD
                                 	SBRC r16, 7            ; Check the MSB (7th bit)
                                 	SBI PORTD, PD7         ; Set PD7 according to the data bit
                                 	SBRC r16, 6            ; Check the 6th bit
                                 	SBI PORTD, PD6         ; Set PD6 according to the data bit
                                 	SBRC r16, 5            ; Check the 5th bit
                                 	SBI PORTD, PD5         ; Set PD5 according to the data bit
                                 	SBRC r16, 4            ; Check the 4th bit
                                 	SBI PORTD, PD4         ; Set PD4 according to the data bit
                                 
                                 	SBI PORTB, PB1         ; Set E pin to HIGH (set LCD to receive the data)
                                 	delay 10
                                 	CBI PORTB, PB1         ; Set E pin to LOW (set LCD to process the data)
                                 
                                 	RJMP LCD_send_a_register_writing_skip_temp_end
                                 	LCD_send_a_register_writing_skip_temp:
                                 	RJMP LCD_send_a_register_writing_skip
                                 	LCD_send_a_register_writing_skip_temp_end:
                                 
                                 	; Clear the pins
                                 	CBI PORTD, PD7         ; Clear PD7
                                 	CBI PORTD, PD6         ; Clear PD6
                                 	CBI PORTD, PD5         ; Clear PD5
                                 	CBI PORTD, PD4         ; Clear PD4
                                 
                                 	; Send the lower 4 bits of the Register to LCD
                                 	SBRC r16, 3            ; Check the 3rd bit
                                 	SBI PORTD, PD7         ; Set PD7 according to the data bit
                                 	SBRC r16, 2            ; Check the 2nd bit
                                 	SBI PORTD, PD6         ; Set PD6 according to the data bit
                                 	SBRC r16, 1            ; Check the 1st bit
                                 	SBI PORTD, PD5         ; Set PD5 according to the data bit
                                 	SBRC r16, 0            ; Check the 0th bit
                                 	SBI PORTD, PD4         ; Set PD4 according to the data bit
                                 
                                 	SBI PORTB, PB1         ; Set E pin to HIGH (set LCD to receive the data)
                                 	delay 10
                                 	CBI PORTB, PB1         ; Set E pin to LOW (set LCD to process the data)
                                 
                                 	; Clear the pins
                                 	CBI PORTD, PD7         ; Clear PD7
                                 	CBI PORTD, PD6         ; Clear PD6
                                 	CBI PORTD, PD5         ; Clear PD5
                                 	CBI PORTD, PD4         ; Clear PD4
                                 	
                                 	LCD_send_a_register_writing_skip:
                                 	INC r18
                                 	rjmp LCD_send_a_register_writing
                                 
                                 	LCD_send_a_register_writing_end:
                                 	POP r30
                                 	POP r29
                                 	POP r28
                                 	POP r19
                                 	POP r18
                                 	POP r17
                                 	POP r16
                                 	POP r15
                                 .endmacro
                                 
                                 
                                 ; Macro to send a string (length <256) to display on the LCD
                                 ; the Z register pair should have the address of the buffer
                                 ; r20 should have the length of the buffer
                                 ;	For example:	
                                 ;	LDI ZL, LOW (2 * hello_string)
                                 ;	LDI ZH, HIGH (2 * hello_string)
                                 ;	LDI r20, string_len
                                 ;	
                                 ; it is recommanded to define the constants (arrays, strings, etc.) at the end of the code segment
                                 ; .db directive is used to declare constants
                                 ;
                                 ;		hello_string:	.db	"Hello World",0
                                 ;		len: .equ	string_len   = (2 * (len - hello_string)) - 1
                                 ;
                                 ;	Note: the string length should be in even numbers, if your string length is
                                 ;		  in odd numbers then add an extra space at the end of the string
                                 ;		  to make overall string length to even number.
                                 .macro LCD_send_a_string
                                 	; save the states of R16 and R17
                                 	PUSH            R16
                                 	PUSH            R17
                                 	PUSH			R20
                                 
                                 	LCD_writeBuffer_LOOP:
                                 		; load the current byte/character pointed to be Z and increment the Z pointer
                                 		LPM             r16, Z+
                                 		; check if the remaining size of the string is non-zero and return if it is
                                 		CPI             r20, 0
                                 		BREQ            LCD_writeBuffer_END
                                 		LCD_writeBuffer_CHAR:
                                 	
                                 		; Send the string character to the LCD
                                 		; Clear the pins
                                 		CBI PORTD, PD7         ; Clear PD7
                                 		CBI PORTD, PD6         ; Clear PD6
                                 		CBI PORTD, PD5         ; Clear PD5
                                 		CBI PORTD, PD4         ; Clear PD4
                                 		SBI PORTB, PB0         ; Set RS pin to HIGH (set LCD mode to "Data Mode")
                                 		; Send the upper 4 bits of the Register to LCD
                                 		SBRC r16, 7            ; Check the MSB (7th bit)
                                 		SBI PORTD, PD7         ; Set PD7 according to the data bit
                                 		SBRC r16, 6            ; Check the 6th bit
                                 		SBI PORTD, PD6         ; Set PD6 according to the data bit
                                 		SBRC r16, 5            ; Check the 5th bit
                                 		SBI PORTD, PD5         ; Set PD5 according to the data bit
                                 		SBRC r16, 4            ; Check the 4th bit
                                 		SBI PORTD, PD4         ; Set PD4 according to the data bit
                                 
                                 		SBI PORTB, PB1         ; Set E pin to HIGH (set LCD to receive the data)
                                 		delay 10
                                 		CBI PORTB, PB1         ; Set E pin to LOW (set LCD to process the data)
                                 
                                 		; Clear the pins
                                 		CBI PORTD, PD7         ; Clear PD7
                                 		CBI PORTD, PD6         ; Clear PD6
                                 		CBI PORTD, PD5         ; Clear PD5
                                 		CBI PORTD, PD4         ; Clear PD4
                                 
                                 		; Send the lower 4 bits of the Register to LCD
                                 		SBRC r16, 3            ; Check the 3rd bit
                                 		SBI PORTD, PD7         ; Set PD7 according to the data bit
                                 		SBRC r16, 2            ; Check the 2nd bit
                                 		SBI PORTD, PD6         ; Set PD6 according to the data bit
                                 		SBRC r16, 1            ; Check the 1st bit
                                 		SBI PORTD, PD5         ; Set PD5 according to the data bit
                                 		SBRC r16, 0            ; Check the 0th bit
                                 		SBI PORTD, PD4         ; Set PD4 according to the data bit
                                 
                                 		SBI PORTB, PB1         ; Set E pin to HIGH (set LCD to receive the data)
                                 		delay 10
                                 		CBI PORTB, PB1         ; Set E pin to LOW (set LCD to process the data)
                                 
                                 		DEC r20
                                 	RJMP            LCD_writeBuffer_LOOP
                                 	LCD_writeBuffer_END:
                                 
                                 	LCD_send_a_command 0x0C ; screen on, Cursor off 
                                 	; restore the states of R16 and R17 and return
                                 	POP				R20
                                 	POP             R17
                                 	POP             R16
                                 .endmacro
                                 
                                 
                                 ; Macro to divide two 8-bit integers
                                 .macro div
                                 ;***************************************************************************
                                 ;* "div8u" - 8/8 Bit Unsigned Division
                                 ;*
                                 ;* This macro divides the two register variables "r16" (dividend) and
                                 ;* "r17" (divisor).
                                 ;* The result (quotient) is placed in "r16" and the remainder in "r15".
                                 ;*
                                 ;***************************************************************************
                                 ; Input:
                                 ;		r16		; dividend
                                 ;		r17		; divisor
                                 ; Output:
                                 ;		r15		; remainder
                                 ;		r16		; quotient
                                 	PUSH r18
                                 
                                 	div8u:
                                 	sub r15,r15		;clear remainder and carry
                                 	ldi r18,9		;init loop counter
                                 	d8u_1:
                                 	rol r16			;shift left dividend
                                 	dec r18			;decrement counter
                                 	brne d8u_2		;if done
                                 	rjmp exit		;return
                                 	d8u_2:
                                 	rol r15			;shift dividend into remainder
                                 	sub r15,r17		;remainder = remainder - divisor
                                 	brcc d8u_3		;if result negative
                                 	add r15,r17		;restore remainder
                                 	clc				;clear carry to be shifted into result
                                 	rjmp d8u_1		;else
                                 	d8u_3:
                                 	sec				;set carry to be shifted into result
                                 	rjmp d8u_1
                                 	exit:
                                 
                                 	POP r18
                                 .endmacro
                                 
                                 
                                 
                                 ; List of all the supported commands to control the LCD
                                 ;
                                 ;  [Command HEX Value]            [Command Description]
                                 ;		0x01						Clear Display Screen
                                 ;		0x30						Function Set: 8-bit, 1 Line, 5x7 Dots
                                 ;		0x38						Function Set: 8-bit, 2 Line, 5x7 Dots
                                 ;		0x20						Function Set: 4-bit, 1 Line, 5x7 Dots
                                 ;		0x28						Function Set: 4-bit, 2 Line, 5x7 Dots
                                 ;		0x06						Entry Mode
                                 ;		0x08						Display off, Cursor off
                                 ;		0x0E						Display on, Cursor on
                                 ;		0x0C						Display on, Cursor off
                                 ;		0x0F						Display on, Cursor blinking
                                 ;		0x18						Shift entire display left
                                 ;		0x1C						Shift entire display right
                                 ;		0x10						Move cursor left by one character
                                 ;		0x14						Move cursor right by one character
                                 ;		0x80						Force cursor to beginning of 1st row
                                 ;		0xC0						Force cursor to beginning of 2nd row
                                 
                                 
                                 
                                 ; ***************************************************************************
                                 ; *		Macros written by:													*
                                 ; *			Syed Tehseen ul Hasan Shah										*
                                 ; *			Lecturer, University of Engineering and Technology Lahore.		*
                                 ; *			03-January-2024												*
                                 .include "UART_Macros.inc" 
                                 
                                 ; UART Serial Read/Write Macros
                                 ;-------------------------------------------
                                 
                                 ; [List of all the available macros in this file]
                                 ;	Serial_begin
                                 ;	Serial_writeChar
                                 ;	Serial_writeReg
                                 ;	Serial_writeReg_ASCII
                                 ;	Serial_writeNewLine
                                 ;	Serial_writeStr
                                 ;	Serial_writeBuffer
                                 ;	Serial_writeBuffer_ASCII
                                 ;	Serial_read
                                 ;	Serial_readStr		pending
                                 
                                 
                                 
                                 ; Macro to initializes the UART to 9600 BAUD at a frequency of 16 MHz (for Arduino UNO ATmega328p)
                                 ; Inputs: none
                                 ; Outputs: none
                                 ; Working: Initilize the UART protocol
                                 ; Registers modified: r16.r17
                                 .macro Serial_begin
                                 .equ            F_CPU           = 16000000		; 16Mhz
                                 .equ            BAUD_RATE       = 9600
                                 .equ            BAUD_PRESCALER  = (F_CPU/(BAUD_RATE * 16)) - 1  ; 103
                                 ; save the states of R16 and R17
                                 PUSH            R16
                                 PUSH            R17
                                 ; initialize UART to 9600 baud
                                 LDI             R16, LOW(BAUD_PRESCALER)
                                 LDI             R17, HIGH(BAUD_PRESCALER)
                                 STS             UBRR0L, R16
                                 STS             UBRR0H, R17
                                 ; enable transmitter and reciever modes
                                 LDI             R16, (1<<TXEN0)|(1<<RXEN0)
                                 STS             UCSR0B, R16
                                 ; set parity to none and 8 data bits, etc.
                                 LDI             R16, (1<<UCSZ01)|(1<<UCSZ00)
                                 STS             UCSR0C, R16
                                 ; restore the states of R16 and R17 and return
                                 POP             R17
                                 POP             R16
                                 .endmacro
                                 
                                 
                                 ; Macro to writes a single character (single byte) to the UART
                                 ; Inputs: an ASCII character as argument
                                 ; Outputs: none
                                 ; Working: sends that ASCII value of the character to the UART
                                 ; Registers modified: r16
                                 .macro Serial_writeChar
                                 ; save the state of R16
                                 PUSH            R16
                                 Serial_writeChar_LOOP:
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 LDS             R16, UCSR0A
                                 SBRS            R16, UDRE0
                                 RJMP            Serial_writeChar_LOOP
                                 ; copy the argument to the UDR0 register to be sent out
                                 LDI				R16, @0
                                 STS             UDR0, R16
                                 ; restore the state of R16 and return
                                 POP             R16
                                 .endmacro
                                 
                                 
                                 ; Macro to writes a single 8-bit register's raw value to the UART
                                 ; Inputs: register as argument
                                 ; Outputs: none
                                 ; Working: sends the raw value of the register to the UART
                                 ; Registers modified: r16
                                 .macro Serial_writeReg
                                 PUSH r16
                                 
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 PUSH r16
                                 Serial_writeReg_LOOP_1:
                                 LDS             R16, UCSR0A
                                 SBRS            R16, UDRE0
                                 RJMP            Serial_writeReg_LOOP_1
                                 POP r16
                                 ; Load r16 register value into data register (UDR0) to send to UART
                                 mov R16, @0
                                 sts UDR0, R16
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 PUSH r16
                                 Serial_writeReg_LOOP_2:
                                 LDS             R16, UCSR0A
                                 SBRS            R16, UDRE0
                                 RJMP            Serial_writeReg_LOOP_2
                                 POP r16
                                 
                                 POP r16
                                 .endmacro
                                 
                                 
                                 ; Macro to writes a single 8-bit register's ASCII-encoded value to the UART
                                 ; Inputs: register as argument
                                 ; Outputs: none
                                 ; Working: sends the ASCII-encoded value of the register to the UART
                                 .macro Serial_writeReg_ASCII
                                 PUSH r15
                                 PUSH r16
                                 PUSH r17
                                 PUSH r18
                                 PUSH r19
                                 PUSH r28
                                 PUSH r29
                                 PUSH r30
                                 
                                 ; Load the received value into r16
                                 mov R16, @0
                                 mov r19, r16	; take backup of origional value to r19
                                 
                                 PUSH r16
                                 Serial_writeReg_ASCII_LOOP:
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 LDS             R16, UCSR0A
                                 SBRS            R16, UDRE0
                                 RJMP            Serial_writeReg_ASCII_LOOP
                                 POP r16
                                 
                                 ; Convert the 8-bit (0-255) integer to ASCII encoded integer
                                 ; by simply spliting it and adding 48 to its individual digits then
                                 ; send those individual digits to UART
                                 
                                 ; Split the integer into individual digits
                                 ldi r28, 0          ; Initialize r28 (ones place) to 0
                                 ldi r29, 0          ; Initialize r29 (tens place) to 0
                                 ldi r30, 0          ; Initialize r30 (hundreds place) to 0
                                 
                                 ; Ones place
                                 ldi r17, 10         ; Load divisor (10) into r17
                                 div					; Divide r16 by 10, result in r16, remainder in r15
                                 mov r28, r15        ; Move remainder (ones place) to r28
                                 
                                 ; Tens place
                                 ldi r17, 10         ; Load divisor (10) into r17
                                 div			        ; Divide r16 by 10, result in r16, remainder in r15
                                 mov r29, r15        ; Move remainder (tens place) to r29
                                 
                                 ; Hundreds place
                                 ldi r17, 10         ; Load divisor (10) into r17
                                 div			        ; Divide r16 by 10, result in r16, remainder in r15
                                 mov r30, r15        ; Move remainder (hundreds place) to r30
                                 
                                 ; Now r28 has the ones place, r29 has the tens place, and r30 has the hundreds place
                                 ; e.g. integer 235 will split into --> r30=2 , r29=3 , r28=5
                                 
                                 LDI r18, 0	; counter for the loop logic
                                 LDI r17, 48 ; 48 will be added to each digit to encode it to ASCII integer
                                 
                                 ; loop to send all 3 register r30, r29 and r28 to UART one by one
                                 Serial_writeReg_ASCII_writing:
                                 cpi r18, 0
                                 BREQ Serial_writeReg_ASCII_writing_L1
                                 cpi r18, 1
                                 BREQ Serial_writeReg_ASCII_writing_L2
                                 cpi r18, 2
                                 BREQ Serial_writeReg_ASCII_writing_L3
                                 rjmp Serial_writeReg_ASCII_writing_end
                                 
                                 ; sending r30 to UART
                                 Serial_writeReg_ASCII_writing_L1:
                                 CPI r19,100
                                 BRLO Serial_writeReg_ASCII_writing_skip	; if the origional number was from 0 to 99, then skip sending r30 to UART
                                 add r30, r17
                                 mov r16, r30
                                 rjmp Serial_writeReg_ASCII_writing_start
                                 
                                 ; sending r29 to UART
                                 Serial_writeReg_ASCII_writing_L2:
                                 CPI r19,10
                                 BRLO Serial_writeReg_ASCII_writing_skip	; if the origional number was from 0 to 9, then skip sending r29 as well
                                 add r29, r17
                                 mov r16, r29
                                 rjmp Serial_writeReg_ASCII_writing_start
                                 
                                 ; sending r28 to UART
                                 Serial_writeReg_ASCII_writing_L3:
                                 add r28, r17
                                 mov r16, r28
                                 rjmp Serial_writeReg_ASCII_writing_start
                                 
                                 Serial_writeReg_ASCII_writing_start:
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 PUSH r16
                                 Serial_writeReg_ASCII_LOOP_1:
                                 LDS             R16, UCSR0A
                                 SBRS            R16, UDRE0
                                 RJMP            Serial_writeReg_ASCII_LOOP_1
                                 POP r16
                                 ; Load r16 register value into data register (UDR0) to send to UART
                                 sts UDR0, R16
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 PUSH r16
                                 Serial_writeReg_ASCII_LOOP_2:
                                 LDS             R16, UCSR0A
                                 SBRS            R16, UDRE0
                                 RJMP            Serial_writeReg_ASCII_LOOP_2
                                 POP r16
                                 
                                 Serial_writeReg_ASCII_writing_skip:
                                 INC r18
                                 rjmp Serial_writeReg_ASCII_writing
                                 
                                 Serial_writeReg_ASCII_writing_end:
                                 POP r30
                                 POP r29
                                 POP r28
                                 POP r19
                                 POP r18
                                 POP r17
                                 POP r16
                                 POP r15
                                 .endmacro
                                 
                                 
                                 ; Macro to writes a new line character to the UART
                                 ; Inputs: none
                                 ; Outputs: none
                                 ; Working: sends CRLF - carrage return (0x0D) and newline (0x0A) characters to the UART
                                 ; Registers modified: r16
                                 .macro Serial_writeNewLine
                                 ; save the state of R16
                                 PUSH            R16
                                 Serial_writeNewLine_LOOP1:
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 LDS             R16, UCSR0A
                                 SBRS            R16, UDRE0
                                 RJMP            Serial_writeNewLine_LOOP1
                                 ; move value 0x0D (\r) to the UDR0 register to be sent out
                                 LDI				R16, 0x0D
                                 STS             UDR0, R16
                                 Serial_writeNewLine_LOOP2:
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 LDS             R16, UCSR0A
                                 SBRS            R16, UDRE0
                                 RJMP            Serial_writeNewLine_LOOP2
                                 ; move value 0x0A (\n) to the UDR0 register to be sent out
                                 LDI				R16, 0x0A
                                 STS             UDR0, R16
                                 ; restore the state of R16 and return
                                 POP             R16
                                 .endmacro
                                 
                                 
                                 ; Macro to writes a NULL terminated string to the UART
                                 ; Inputs: ZH:ZL - SRAM buffer address from where to the string is stored
                                 ; Outputs: none
                                 ; Working: sends the string via UART
                                 ; Registers modified: r16,r17,Z
                                 ;
                                 ;	For example:
                                 ;		LDI ZL, LOW (2 * hello_string)
                                 ;		LDI ZH, HIGH (2 * hello_string)
                                 ;		Serial_writeStr
                                 ;
                                 ;	It is recommanded to define the constent strings at the end of the code segment.
                                 ;	Optionally you can use CRLF (carriage return/line feed) characters 0x0D and 0x0A at the end of the string
                                 ;	the string should be terminated with 0.
                                 ;	The overall length of the string (including CRLF and ending zero) must be even number of bytes.
                                 ;	e.g.
                                 ;			hello_string:	.db	"Hello World",0x0D,0x0A,0
                                 ;
                                 ;	.db directive is used to decalre constants
                                 ;
                                 ;	Note: the string length should be in even numbers, if your string length is
                                 ;		  in odd numbers then add an extra space at the end of the string
                                 ;		  to make overall string length to even number.
                                 ;
                                 .macro Serial_writeStr
                                 ; save the states of R16 and R17
                                 PUSH            R16
                                 PUSH            R17
                                 Serial_writeStr_LOOP:
                                 ; load the current byte/character pointed to be Z and increment the Z pointer
                                 LPM             R16, Z+
                                 ; if the current character is 0/NULL, return from the routine since the string has been used
                                 CPI             R16, 0
                                 BREQ            Serial_writeStr_END
                                 Serial_writeStr_CHAR:
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 LDS             R17, UCSR0A
                                 SBRS            R17, UDRE0
                                 RJMP            Serial_writeStr_CHAR
                                 ; copy the current character to the UDR0 register to send it out and jump back to the start
                                 STS             UDR0, R16
                                 RJMP            Serial_writeStr_LOOP
                                 Serial_writeStr_END:
                                 ; restore the states of R16 and R17 and return
                                 POP             R17
                                 POP             R16
                                 .endmacro
                                 
                                 
                                 ; Macro to writes a buffer (constant integer array, etc.) of a given length (<256 bytes) to the UART
                                 ; Inputs: ZH:ZL - SRAM buffer address from where to the sending data is placed
                                 ;		  r20 should have the length of the buffer
                                 ; Outputs: none
                                 ; Working: sends the buffer via UART
                                 ; Registers modified: r16,r17,r20,Z
                                 ;
                                 ;For example:
                                 ;		LDI ZL, LOW (2 * hello_buffer)
                                 ;		LDI ZH, HIGH (2 * hello_buffer)
                                 ;		LDI r20, buffer_len
                                 ;
                                 ;	it is recommanded to define the buffer at the end of the code segment
                                 ;		hello_buffer:	.db	1,2,3,4,5,6
                                 ;		len: .equ	buffer_len   = 2 * (len - hello_buffer)
                                 ;
                                 ;	.db directive is used to decalre constants
                                 ;
                                 ;	Note: the string length should be in even numbers, if your string length is
                                 ;		  in odd numbers then add an extra space at the end of the string
                                 ;		  to make overall string length to even number.
                                 ;
                                 .macro Serial_writeBuffer
                                 ; save the states of R16, R17 and r20
                                 PUSH            R16
                                 PUSH            R17
                                 PUSH			R20
                                 Serial_writeBuffer_LOOP:
                                 ; load the current byte pointed to be Z and increment the Z pointer
                                 LPM             R16, Z+
                                 ; check if the remaining size of the buffer is non-zero and return if it is
                                 CPI             R20, 0
                                 BREQ            Serial_writeBuffer_END
                                 Serial_writeBuffer_CHAR:
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 LDS             R17, UCSR0A
                                 SBRS            R17, UDRE0
                                 RJMP            Serial_writeBuffer_CHAR
                                 ; copy the current character to the UDR0 register to send it out and jump back to the start
                                 STS             UDR0, R16
                                 DEC             R20
                                 RJMP            Serial_writeBuffer_LOOP
                                 Serial_writeBuffer_END:
                                 ; restore the states of R16, R17 and r20
                                 POP				R20
                                 POP             R17
                                 POP             R16
                                 .endmacro
                                 
                                 
                                 ; Macro to writes an ASCII-encoded buffer (constant integer array, etc.) of a given length (<256 bytes) to the UART
                                 ; Inputs: ZH:ZL - SRAM buffer address from where to the sending data is placed
                                 ;		  r20 should have the length of the buffer
                                 ; Outputs: none
                                 ; Working: sends the buffer via UART
                                 ; Registers modified: r16,r17,r20,Z
                                 ;
                                 ;For example:
                                 ;		LDI ZL, LOW (2 * hello_buffer)
                                 ;		LDI ZH, HIGH (2 * hello_buffer)
                                 ;		LDI r20, buffer_len
                                 ;
                                 ;	it is recommanded to define the buffer at the end of the code segment
                                 ;		hello_buffer:	.db	1,2,3,4,5,6
                                 ;		len: .equ	buffer_len   = 2 * (len - hello_buffer)
                                 ;
                                 ;	.db directive is used to decalre constants
                                 ;
                                 ;	Note: the string length should be in even numbers, if your string length is
                                 ;		  in odd numbers then add an extra space at the end of the string
                                 ;		  to make overall string length to even number.
                                 ;
                                 .macro Serial_writeBuffer_ASCII
                                 ; save the states of R16, R17 and r20
                                 PUSH            R16
                                 PUSH            R17
                                 PUSH			R18
                                 PUSH			R20
                                 
                                 LDI r18, 48 ; 48 will be added to each digit to encode it to ASCII integer
                                 
                                 Serial_writeBuffer_LOOP:
                                 ; load the current byte pointed to be Z and increment the Z pointer
                                 LPM             R16, Z+
                                 add r16, r18		; convert to ASCII encoded integer
                                 ; check if the remaining size of the buffer is non-zero and return if it is
                                 CPI             R20, 0
                                 BREQ            Serial_writeBuffer_END
                                 Serial_writeBuffer_CHAR:
                                 ; wait for the write buffer to become empty (bit UDRE0 of UCSR0A register should be set)
                                 LDS             R17, UCSR0A
                                 SBRS            R17, UDRE0
                                 RJMP            Serial_writeBuffer_CHAR
                                 ; copy the current character to the UDR0 register to send it out and jump back to the start
                                 STS             UDR0, R16
                                 DEC             R20
                                 RJMP            Serial_writeBuffer_LOOP
                                 Serial_writeBuffer_END:
                                 ; restore the states of R16, R17 and r20
                                 POP				R20
                                 POP				R18
                                 POP             R17
                                 POP             R16
                                 .endmacro
                                 
                                 
                                 ; Macro to read a single byte from the UART
                                 ; Inputs: register to hold the received byte
                                 ; Outputs: r16
                                 ; Working: receives byte via UART and stores in a r16 register
                                 .macro Serial_read
                                 
                                 ;Serial_read_WAIT:
                                 ; wait till a byte is in the buffer
                                 LDS             R16, UCSR0A
                                 SBRS            R16, RXC0
                                 RJMP            Serial_read_Skip
                                 ;RJMP            Serial_read_WAIT
                                 
                                 Serial_read_Start:
                                 ; read the byte
                                 LDS             r16, UDR0
                                 
                                 rjmp Serial_read_END
                                 Serial_read_Skip:
                                 LDI				r16,0
                                 Serial_read_END:
                                 .endmacro
                                 
                                 
                                 ; Macro to receive a string from the UART and store in variable (array)
                                 ; Inputs: ZH:ZL - SRAM buffer address for received string
                                 ; Outputs: r16 will contain 0 if no data received
                                 ; Working: receives string via UART and stores in data memory until carriage return (0x0D) received
                                 ; Registers modified: r16, r17, XL, XH
                                 ;
                                 ;	For example:
                                 ;		.dseg
                                 ;		.org SRAM_START
                                 ;			buffer:	.byte	20		; 20 bytes reserved
                                 ;		.cseg
                                 ;		.org 0x0000
                                 ;			LDI ZL, LOW (buffer)
                                 ;			LDI ZH, HIGH (buffer)
                                 ;			Serial_readStr
                                 ;
                                 .macro Serial_readStr
                                 ; save the state of R17
                                 PUSH			R17
                                 
                                 ;Serial_readStr_WAIT:
                                 ; wait till a byte is in the buffer
                                 LDS             r16, UCSR0A
                                 SBRS            r16, RXC0
                                 RJMP            Serial_readStr_Skip
                                 ;RJMP            Serial_readStr_WAIT
                                 
                                 Serial_readStr_Start:
                                 lds		r16, UDR0				; get received character
                                 
                                 cpi		r16, 0x0D				; check if received char is CR
                                 breq	Serial_readStr_END		; branch if CR received
                                 
                                 st	Z+, r16						; store character to buffer
                                 rjmp Serial_readStr_Start		; get another character
                                 
                                 
                                 Serial_readStr_Skip:
                                 LDI				r16, 0			; set r16 to 0 if there is no data on UART
                                 rjmp Serial_readStr_Skip2
                                 Serial_readStr_END:
                                 LDI				r16, 1			; set r16 to 1 if data is received on UART
                                 Serial_readStr_Skip2:
                                 POP				R17
                                 .endmacro
                                 
                                 
                                 
                                 
                                 ; ***************************************************************************
                                 ; *		Macros written by:													*
                                 ; *			Syed Tehseen ul Hasan Shah										*
                                 ; *			Lecturer, University of Engineering and Technology Lahore.		*
                                 ; *			24-December-2023												*
                                 
                                 .equ input=14
                                 .cseg
                                 
                                 .org 0x00 
                                 
000000 940c 0112                 jmp reset
                                 
                                 .org 0x0024
000024 c000                      Rjmp InterpetOnReceiver
                                 
                                 InterpetOnReceiver:
000025 9100 00c0
000027 ff07
000028 c003
000029 9100 00c6
00002b c001
00002c e000                      	Serial_read
00002d 2f90                      	mov r25,r16
00002e 930f
00002f e001
000030 985f
000031 985e
000032 985d
000033 985c
000034 9828
000035 fd07
000036 9a5f
000037 fd06
000038 9a5e
000039 fd05
00003a 9a5d
00003b fd04
00003c 9a5c
00003d 9a29
00003e 932f
00003f 938f
000040 939f
000041 e021
000042 e38e
000043 e99c
000044 9701
000045 f7f1
000046 952a
000047 f7d1
000048 0000
000049 919f
00004a 918f
00004b 912f
00004c 9829
00004d 985f
00004e 985e
00004f 985d
000050 985c
000051 fd03
000052 9a5f
000053 fd02
000054 9a5e
000055 fd01
000056 9a5d
000057 fd00
000058 9a5c
000059 9a29
00005a 932f
00005b 938f
00005c 939f
00005d e021
00005e e38e
00005f e99c
000060 9701
000061 f7f1
000062 952a
000063 f7d1
000064 0000
000065 919f
000066 918f
000067 912f
000068 9829
000069 985f
00006a 985e
00006b 985d
00006c 985c
00006d 910f                      	LCD_send_a_command 0x01
00006e 92ff
00006f 930f
000070 931f
000071 932f
000072 933f
000073 93cf
000074 93df
000075 93ef
000076 2f09
000077 2f30
000078 e0c0
000079 e0d0
00007a e0e0
00007b e01a
00007c 932f
00007d 18ff
00007e e029
00007f 1f00
000080 952a
000081 f409
000082 c008
000083 1cff
000084 1af1
000085 f418
000086 0ef1
000087 9488
000088 cff6
000089 9408
00008a cff4
00008b 912f
00008c 2dcf
00008d e01a
00008e 932f
00008f 18ff
000090 e029
000091 1f00
000092 952a
000093 f409
000094 c008
000095 1cff
000096 1af1
000097 f418
000098 0ef1
000099 9488
00009a cff6
00009b 9408
00009c cff4
00009d 912f
00009e 2ddf
00009f e01a
0000a0 932f
0000a1 18ff
0000a2 e029
0000a3 1f00
0000a4 952a
0000a5 f409
0000a6 c008
0000a7 1cff
0000a8 1af1
0000a9 f418
0000aa 0ef1
0000ab 9488
0000ac cff6
0000ad 9408
0000ae cff4
0000af 912f
0000b0 2def
0000b1 e020
0000b2 e310
0000b3 3020
0000b4 f029
0000b5 3021
0000b6 f041
0000b7 3022
0000b8 f059
0000b9 c04e
0000ba 3634
0000bb f148
0000bc 0fe1
0000bd 2f0e
0000be c008
0000bf 303a
0000c0 f120
0000c1 0fd1
0000c2 2f0d
0000c3 c003
0000c4 0fc1
0000c5 2f0c
0000c6 c000
0000c7 985f
0000c8 985e
0000c9 985d
0000ca 985c
0000cb 9a28
0000cc fd07
0000cd 9a5f
0000ce fd06
0000cf 9a5e
0000d0 fd05
0000d1 9a5d
0000d2 fd04
0000d3 9a5c
0000d4 9a29
0000d5 932f
0000d6 938f
0000d7 939f
0000d8 e021
0000d9 e38e
0000da e99c
0000db 9701
0000dc f7f1
0000dd 952a
0000de f7d1
0000df 0000
0000e0 919f
0000e1 918f
0000e2 912f
0000e3 9829
0000e4 c001
0000e5 c020
0000e6 985f
0000e7 985e
0000e8 985d
0000e9 985c
0000ea fd03
0000eb 9a5f
0000ec fd02
0000ed 9a5e
0000ee fd01
0000ef 9a5d
0000f0 fd00
0000f1 9a5c
0000f2 9a29
0000f3 932f
0000f4 938f
0000f5 939f
0000f6 e021
0000f7 e38e
0000f8 e99c
0000f9 9701
0000fa f7f1
0000fb 952a
0000fc f7d1
0000fd 0000
0000fe 919f
0000ff 918f
000100 912f
000101 9829
000102 985f
000103 985e
000104 985d
000105 985c
000106 9523
000107 cfab
000108 91ef
000109 91df
00010a 91cf
00010b 913f
00010c 912f
00010d 911f
00010e 910f
00010f 90ff                      	LCD_send_a_register r25
                                 	l1:
000110 cfff                      		rjmp l1
                                 
000111 9518                      reti
                                 
                                 reset:
                                     ; Initialize stack pointer
000112 e008                          LDI r16, high(RAMEND)
000113 bf0e                          OUT SPH, r16
000114 ef0f                          LDI r16, low(RAMEND)
000115 bf0d                          OUT SPL, r16
000116 930f
000117 9100 00c0
000119 ff05
00011a cffc
00011b e502
00011c 9300 00c6
00011e 910f                      	Serial_writeChar 'R'
00011f 9478                          SEI
                                 
000120 9a54
000121 9a55
000122 9a56
000123 9a57
000124 9a20
000125 9a21
000126 9a25
000127 932f
000128 938f
000129 939f
00012a e025
00012b e38e
00012c e99c
00012d 9701
00012e f7f1
00012f 952a
000130 f7d1
000131 0000
000132 919f
000133 918f
000134 912f
000135 9828
000136 9829
000137 930f
000138 e003
000139 985f
00013a 985e
00013b 985d
00013c 985c
00013d 9828
00013e fd07
00013f 9a5f
000140 fd06
000141 9a5e
000142 fd05
000143 9a5d
000144 fd04
000145 9a5c
000146 9a29
000147 932f
000148 938f
000149 939f
00014a e021
00014b e38e
00014c e99c
00014d 9701
00014e f7f1
00014f 952a
000150 f7d1
000151 0000
000152 919f
000153 918f
000154 912f
000155 9829
000156 985f
000157 985e
000158 985d
000159 985c
00015a fd03
00015b 9a5f
00015c fd02
00015d 9a5e
00015e fd01
00015f 9a5d
000160 fd00
000161 9a5c
000162 9a29
000163 932f
000164 938f
000165 939f
000166 e021
000167 e38e
000168 e99c
000169 9701
00016a f7f1
00016b 952a
00016c f7d1
00016d 0000
00016e 919f
00016f 918f
000170 912f
000171 9829
000172 985f
000173 985e
000174 985d
000175 985c
000176 910f
000177 932f
000178 938f
000179 939f
00017a e020
00017b e38e
00017c e99c
00017d 9701
00017e f7f1
00017f 952a
000180 f7d1
000181 0000
000182 919f
000183 918f
000184 912f
000185 930f
000186 e003
000187 985f
000188 985e
000189 985d
00018a 985c
00018b 9828
00018c fd07
00018d 9a5f
00018e fd06
00018f 9a5e
000190 fd05
000191 9a5d
000192 fd04
000193 9a5c
000194 9a29
000195 932f
000196 938f
000197 939f
000198 e021
000199 e38e
00019a e99c
00019b 9701
00019c f7f1
00019d 952a
00019e f7d1
00019f 0000
0001a0 919f
0001a1 918f
0001a2 912f
0001a3 9829
0001a4 985f
0001a5 985e
0001a6 985d
0001a7 985c
0001a8 fd03
0001a9 9a5f
0001aa fd02
0001ab 9a5e
0001ac fd01
0001ad 9a5d
0001ae fd00
0001af 9a5c
0001b0 9a29
0001b1 932f
0001b2 938f
0001b3 939f
0001b4 e021
0001b5 e38e
0001b6 e99c
0001b7 9701
0001b8 f7f1
0001b9 952a
0001ba f7d1
0001bb 0000
0001bc 919f
0001bd 918f
0001be 912f
0001bf 9829
0001c0 985f
0001c1 985e
0001c2 985d
0001c3 985c
0001c4 910f
0001c5 932f
0001c6 938f
0001c7 939f
0001c8 e020
0001c9 e38e
0001ca e99c
0001cb 9701
0001cc f7f1
0001cd 952a
0001ce f7d1
0001cf 0000
0001d0 919f
0001d1 918f
0001d2 912f
0001d3 930f
0001d4 e003
0001d5 985f
0001d6 985e
0001d7 985d
0001d8 985c
0001d9 9828
0001da fd07
0001db 9a5f
0001dc fd06
0001dd 9a5e
0001de fd05
0001df 9a5d
0001e0 fd04
0001e1 9a5c
0001e2 9a29
0001e3 932f
0001e4 938f
0001e5 939f
0001e6 e021
0001e7 e38e
0001e8 e99c
0001e9 9701
0001ea f7f1
0001eb 952a
0001ec f7d1
0001ed 0000
0001ee 919f
0001ef 918f
0001f0 912f
0001f1 9829
0001f2 985f
0001f3 985e
0001f4 985d
0001f5 985c
0001f6 fd03
0001f7 9a5f
0001f8 fd02
0001f9 9a5e
0001fa fd01
0001fb 9a5d
0001fc fd00
0001fd 9a5c
0001fe 9a29
0001ff 932f
000200 938f
000201 939f
000202 e021
000203 e38e
000204 e99c
000205 9701
000206 f7f1
000207 952a
000208 f7d1
000209 0000
00020a 919f
00020b 918f
00020c 912f
00020d 9829
00020e 985f
00020f 985e
000210 985d
000211 985c
000212 910f
000213 932f
000214 938f
000215 939f
000216 e020
000217 e38e
000218 e99c
000219 9701
00021a f7f1
00021b 952a
00021c f7d1
00021d 0000
00021e 919f
00021f 918f
000220 912f
000221 930f
000222 e002
000223 985f
000224 985e
000225 985d
000226 985c
000227 9828
000228 fd07
000229 9a5f
00022a fd06
00022b 9a5e
00022c fd05
00022d 9a5d
00022e fd04
00022f 9a5c
000230 9a29
000231 932f
000232 938f
000233 939f
000234 e021
000235 e38e
000236 e99c
000237 9701
000238 f7f1
000239 952a
00023a f7d1
00023b 0000
00023c 919f
00023d 918f
00023e 912f
00023f 9829
000240 985f
000241 985e
000242 985d
000243 985c
000244 fd03
000245 9a5f
000246 fd02
000247 9a5e
000248 fd01
000249 9a5d
00024a fd00
00024b 9a5c
00024c 9a29
00024d 932f
00024e 938f
00024f 939f
000250 e021
000251 e38e
000252 e99c
000253 9701
000254 f7f1
000255 952a
000256 f7d1
000257 0000
000258 919f
000259 918f
00025a 912f
00025b 9829
00025c 985f
00025d 985e
00025e 985d
00025f 985c
000260 910f
000261 930f
000262 e208
000263 985f
000264 985e
000265 985d
000266 985c
000267 9828
000268 fd07
000269 9a5f
00026a fd06
00026b 9a5e
00026c fd05
00026d 9a5d
00026e fd04
00026f 9a5c
000270 9a29
000271 932f
000272 938f
000273 939f
000274 e021
000275 e38e
000276 e99c
000277 9701
000278 f7f1
000279 952a
00027a f7d1
00027b 0000
00027c 919f
00027d 918f
00027e 912f
00027f 9829
000280 985f
000281 985e
000282 985d
000283 985c
000284 fd03
000285 9a5f
000286 fd02
000287 9a5e
000288 fd01
000289 9a5d
00028a fd00
00028b 9a5c
00028c 9a29
00028d 932f
00028e 938f
00028f 939f
000290 e021
000291 e38e
000292 e99c
000293 9701
000294 f7f1
000295 952a
000296 f7d1
000297 0000
000298 919f
000299 918f
00029a 912f
00029b 9829
00029c 985f
00029d 985e
00029e 985d
00029f 985c
0002a0 910f
0002a1 930f
0002a2 e00c
0002a3 985f
0002a4 985e
0002a5 985d
0002a6 985c
0002a7 9828
0002a8 fd07
0002a9 9a5f
0002aa fd06
0002ab 9a5e
0002ac fd05
0002ad 9a5d
0002ae fd04
0002af 9a5c
0002b0 9a29
0002b1 932f
0002b2 938f
0002b3 939f
0002b4 e021
0002b5 e38e
0002b6 e99c
0002b7 9701
0002b8 f7f1
0002b9 952a
0002ba f7d1
0002bb 0000
0002bc 919f
0002bd 918f
0002be 912f
0002bf 9829
0002c0 985f
0002c1 985e
0002c2 985d
0002c3 985c
0002c4 fd03
0002c5 9a5f
0002c6 fd02
0002c7 9a5e
0002c8 fd01
0002c9 9a5d
0002ca fd00
0002cb 9a5c
0002cc 9a29
0002cd 932f
0002ce 938f
0002cf 939f
0002d0 e021
0002d1 e38e
0002d2 e99c
0002d3 9701
0002d4 f7f1
0002d5 952a
0002d6 f7d1
0002d7 0000
0002d8 919f
0002d9 918f
0002da 912f
0002db 9829
0002dc 985f
0002dd 985e
0002de 985d
0002df 985c
0002e0 910f
0002e1 930f
0002e2 e001
0002e3 985f
0002e4 985e
0002e5 985d
0002e6 985c
0002e7 9828
0002e8 fd07
0002e9 9a5f
0002ea fd06
0002eb 9a5e
0002ec fd05
0002ed 9a5d
0002ee fd04
0002ef 9a5c
0002f0 9a29
0002f1 932f
0002f2 938f
0002f3 939f
0002f4 e021
0002f5 e38e
0002f6 e99c
0002f7 9701
0002f8 f7f1
0002f9 952a
0002fa f7d1
0002fb 0000
0002fc 919f
0002fd 918f
0002fe 912f
0002ff 9829
000300 985f
000301 985e
000302 985d
000303 985c
000304 fd03
000305 9a5f
000306 fd02
000307 9a5e
000308 fd01
000309 9a5d
00030a fd00
00030b 9a5c
00030c 9a29
00030d 932f
00030e 938f
00030f 939f
000310 e021
000311 e38e
000312 e99c
000313 9701
000314 f7f1
000315 952a
000316 f7d1
000317 0000
000318 919f
000319 918f
00031a 912f
00031b 9829
00031c 985f
00031d 985e
00031e 985d
00031f 985c
000320 910f
000321 932f
000322 938f
000323 939f
000324 e021
000325 e38e
000326 e99c
000327 9701
000328 f7f1
000329 952a
00032a f7d1
00032b 0000
00032c 919f
00032d 918f
00032e 912f
00032f 930f
000330 e006
000331 985f
000332 985e
000333 985d
000334 985c
000335 9828
000336 fd07
000337 9a5f
000338 fd06
000339 9a5e
00033a fd05
00033b 9a5d
00033c fd04
00033d 9a5c
00033e 9a29
00033f 932f
000340 938f
000341 939f
000342 e021
000343 e38e
000344 e99c
000345 9701
000346 f7f1
000347 952a
000348 f7d1
000349 0000
00034a 919f
00034b 918f
00034c 912f
00034d 9829
00034e 985f
00034f 985e
000350 985d
000351 985c
000352 fd03
000353 9a5f
000354 fd02
000355 9a5e
000356 fd01
000357 9a5d
000358 fd00
000359 9a5c
00035a 9a29
00035b 932f
00035c 938f
00035d 939f
00035e e021
00035f e38e
000360 e99c
000361 9701
000362 f7f1
000363 952a
000364 f7d1
000365 0000
000366 919f
000367 918f
000368 912f
000369 9829
00036a 985f
00036b 985e
00036c 985d
00036d 985c
00036e 910f                       LCD_init
00036f 9a2d                       LCD_backlight_ON
000370 930f
000371 931f
000372 e607
000373 e010
000374 9300 00c4
000376 9310 00c5
000378 e108
000379 9300 00c1
00037b e006
00037c 9300 00c2
00037e 911f
00037f 910f                       Serial_begin
                                 
000380 e060                       LDI r22,0
000381 e391                       LDI r25,'1'
                                 
                                 loop: 
000382 930f
000383 e001
000384 985f
000385 985e
000386 985d
000387 985c
000388 9828
000389 fd07
00038a 9a5f
00038b fd06
00038c 9a5e
00038d fd05
00038e 9a5d
00038f fd04
000390 9a5c
000391 9a29
000392 932f
000393 938f
000394 939f
000395 e021
000396 e38e
000397 e99c
000398 9701
000399 f7f1
00039a 952a
00039b f7d1
00039c 0000
00039d 919f
00039e 918f
00039f 912f
0003a0 9829
0003a1 985f
0003a2 985e
0003a3 985d
0003a4 985c
0003a5 fd03
0003a6 9a5f
0003a7 fd02
0003a8 9a5e
0003a9 fd01
0003aa 9a5d
0003ab fd00
0003ac 9a5c
0003ad 9a29
0003ae 932f
0003af 938f
0003b0 939f
0003b1 e021
0003b2 e38e
0003b3 e99c
0003b4 9701
0003b5 f7f1
0003b6 952a
0003b7 f7d1
0003b8 0000
0003b9 919f
0003ba 918f
0003bb 912f
0003bc 9829
0003bd 985f
0003be 985e
0003bf 985d
0003c0 985c
0003c1 910f                      	LCD_send_a_command 0x01  ; clear the LCD 
                                 
0003c2 3391                      	 cpi r25,'1'
0003c3 f049                      	 breq function1  ; Branch to the label "function1" if the Zero Flag (Z) is set
                                 
0003c4 3392                      	 cpi r25,'2'
0003c5 f051                      	 breq function2
                                 	 
0003c6 3393                      	 cpi r25,'3'
0003c7 f059                      	 breq function3
                                 	 
0003c8 3394                      	 cpi r25,'4'
0003c9 f061                      	 breq function4
                                 
0003ca 3395                      	 cpi r25,'5'
0003cb f069                      	 breq function5
                                 
0003cc cfb5                      	rjmp loop
                                 
                                 	 function1: 
0003cd 940e 0409                 		call button1_functionality
0003cf cfb2                      		rjmp loop
                                 
                                 	function2: 
0003d0 940e 0ab2                 		call button2_functionality
0003d2 cfaf                      		rjmp loop
                                 
                                 	function3: 
0003d3 940e 0af4                 		call button3_functionality
0003d5 cfac                      		rjmp loop
                                 
                                 	function4: 
0003d6 940e 0c54                 		call button4_functionality_off
0003d8 cfa9                      		rjmp loop
                                 
                                 	function5: 
0003d9 940e 0c57                 		call button5_functionality
0003db 9563                      		inc r22
0003dc 3161                      		cpi r22,17
0003dd f009                      		breq reset_r22
0003de c001                      		rjmp skip
                                 		reset_r22:
0003df e060                      			ldi r22,0
                                 		skip:
                                 
                                 		
0003e0 0000                      		nop
                                 
0003e1 cfa0                      		rjmp loop
                                 
0003e2 cf9f                      rjmp loop 
                                 
                                 light_off:
                                 
0003e3 932f
0003e4 938f
0003e5 939f
0003e6 e624
0003e7 e38e
0003e8 e99c
0003e9 9701
0003ea f7f1
0003eb 952a
0003ec f7d1
0003ed 0000
0003ee 919f
0003ef 918f
0003f0 912f                      	 delay 1000 
0003f1 9180 000e                 	 lds r24,input
0003f3 3082                      	 cpi r24,2
0003f4 f371                      	 breq light_off
0003f5 e052                      	 ldi r21,2
0003f6 9350 000e                 	 sts input,r21
                                 
                                 
0003f8 982d                      	 cbi PORTB,PB5
0003f9 932f
0003fa 938f
0003fb 939f
0003fc ec28
0003fd e38e
0003fe e99c
0003ff 9701
000400 f7f1
000401 952a
000402 f7d1
000403 0000
000404 919f
000405 918f
000406 912f                      	 delay 2000
000407 9a2d                      	 sbi PORTB,5
000408 cf79                      	 rjmp loop
                                 
                                 
                                  button1_functionality:
                                 
000409 930f
00040a e001
00040b 985f
00040c 985e
00040d 985d
00040e 985c
00040f 9828
000410 fd07
000411 9a5f
000412 fd06
000413 9a5e
000414 fd05
000415 9a5d
000416 fd04
000417 9a5c
000418 9a29
000419 932f
00041a 938f
00041b 939f
00041c e021
00041d e38e
00041e e99c
00041f 9701
000420 f7f1
000421 952a
000422 f7d1
000423 0000
000424 919f
000425 918f
000426 912f
000427 9829
000428 985f
000429 985e
00042a 985d
00042b 985c
00042c fd03
00042d 9a5f
00042e fd02
00042f 9a5e
000430 fd01
000431 9a5d
000432 fd00
000433 9a5c
000434 9a29
000435 932f
000436 938f
000437 939f
000438 e021
000439 e38e
00043a e99c
00043b 9701
00043c f7f1
00043d 952a
00043e f7d1
00043f 0000
000440 919f
000441 918f
000442 912f
000443 9829
000444 985f
000445 985e
000446 985d
000447 985c
000448 910f                      	LCD_send_a_command 0x01  ; clear the LCD
                                 
000449 e6e6                      	LDI             ZL, LOW (2 * button1_message1)
00044a e1fb                      	LDI             ZH, HIGH (2 * button1_message1)
00044b e04d                      	LDI             R20, button1_message1_len
                                 
00044c 930f
00044d 931f
00044e 934f
00044f 9105
000450 3040
000451 f1d9
000452 985f
000453 985e
000454 985d
000455 985c
000456 9a28
000457 fd07
000458 9a5f
000459 fd06
00045a 9a5e
00045b fd05
00045c 9a5d
00045d fd04
00045e 9a5c
00045f 9a29
000460 932f
000461 938f
000462 939f
000463 e021
000464 e38e
000465 e99c
000466 9701
000467 f7f1
000468 952a
000469 f7d1
00046a 0000
00046b 919f
00046c 918f
00046d 912f
00046e 9829
00046f 985f
000470 985e
000471 985d
000472 985c
000473 fd03
000474 9a5f
000475 fd02
000476 9a5e
000477 fd01
000478 9a5d
000479 fd00
00047a 9a5c
00047b 9a29
00047c 932f
00047d 938f
00047e 939f
00047f e021
000480 e38e
000481 e99c
000482 9701
000483 f7f1
000484 952a
000485 f7d1
000486 0000
000487 919f
000488 918f
000489 912f
00048a 9829
00048b 954a
00048c cfc2
00048d 930f
00048e e00c
00048f 985f
000490 985e
000491 985d
000492 985c
000493 9828
000494 fd07
000495 9a5f
000496 fd06
000497 9a5e
000498 fd05
000499 9a5d
00049a fd04
00049b 9a5c
00049c 9a29
00049d 932f
00049e 938f
00049f 939f
0004a0 e021
0004a1 e38e
0004a2 e99c
0004a3 9701
0004a4 f7f1
0004a5 952a
0004a6 f7d1
0004a7 0000
0004a8 919f
0004a9 918f
0004aa 912f
0004ab 9829
0004ac 985f
0004ad 985e
0004ae 985d
0004af 985c
0004b0 fd03
0004b1 9a5f
0004b2 fd02
0004b3 9a5e
0004b4 fd01
0004b5 9a5d
0004b6 fd00
0004b7 9a5c
0004b8 9a29
0004b9 932f
0004ba 938f
0004bb 939f
0004bc e021
0004bd e38e
0004be e99c
0004bf 9701
0004c0 f7f1
0004c1 952a
0004c2 f7d1
0004c3 0000
0004c4 919f
0004c5 918f
0004c6 912f
0004c7 9829
0004c8 985f
0004c9 985e
0004ca 985d
0004cb 985c
0004cc 910f
0004cd 914f
0004ce 911f
0004cf 910f                      	LCD_send_a_string button1_message1
                                 
0004d0 930f
0004d1 ec00
0004d2 985f
0004d3 985e
0004d4 985d
0004d5 985c
0004d6 9828
0004d7 fd07
0004d8 9a5f
0004d9 fd06
0004da 9a5e
0004db fd05
0004dc 9a5d
0004dd fd04
0004de 9a5c
0004df 9a29
0004e0 932f
0004e1 938f
0004e2 939f
0004e3 e021
0004e4 e38e
0004e5 e99c
0004e6 9701
0004e7 f7f1
0004e8 952a
0004e9 f7d1
0004ea 0000
0004eb 919f
0004ec 918f
0004ed 912f
0004ee 9829
0004ef 985f
0004f0 985e
0004f1 985d
0004f2 985c
0004f3 fd03
0004f4 9a5f
0004f5 fd02
0004f6 9a5e
0004f7 fd01
0004f8 9a5d
0004f9 fd00
0004fa 9a5c
0004fb 9a29
0004fc 932f
0004fd 938f
0004fe 939f
0004ff e021
000500 e38e
000501 e99c
000502 9701
000503 f7f1
000504 952a
000505 f7d1
000506 0000
000507 919f
000508 918f
000509 912f
00050a 9829
00050b 985f
00050c 985e
00050d 985d
00050e 985c
00050f 910f                      	LCD_send_a_command 0xC0  ; Set Cursor to second line
                                 
000510 e7e4                      	LDI             ZL, LOW (2 * button1_message1_2)
000511 e1fb                      	LDI             ZH, HIGH (2 * button1_message1_2)
000512 e04d                      	LDI             R20, button1_message1_2_len
                                 
000513 930f
000514 931f
000515 934f
000516 9105
000517 3040
000518 f1d9
000519 985f
00051a 985e
00051b 985d
00051c 985c
00051d 9a28
00051e fd07
00051f 9a5f
000520 fd06
000521 9a5e
000522 fd05
000523 9a5d
000524 fd04
000525 9a5c
000526 9a29
000527 932f
000528 938f
000529 939f
00052a e021
00052b e38e
00052c e99c
00052d 9701
00052e f7f1
00052f 952a
000530 f7d1
000531 0000
000532 919f
000533 918f
000534 912f
000535 9829
000536 985f
000537 985e
000538 985d
000539 985c
00053a fd03
00053b 9a5f
00053c fd02
00053d 9a5e
00053e fd01
00053f 9a5d
000540 fd00
000541 9a5c
000542 9a29
000543 932f
000544 938f
000545 939f
000546 e021
000547 e38e
000548 e99c
000549 9701
00054a f7f1
00054b 952a
00054c f7d1
00054d 0000
00054e 919f
00054f 918f
000550 912f
000551 9829
000552 954a
000553 cfc2
000554 930f
000555 e00c
000556 985f
000557 985e
000558 985d
000559 985c
00055a 9828
00055b fd07
00055c 9a5f
00055d fd06
00055e 9a5e
00055f fd05
000560 9a5d
000561 fd04
000562 9a5c
000563 9a29
000564 932f
000565 938f
000566 939f
000567 e021
000568 e38e
000569 e99c
00056a 9701
00056b f7f1
00056c 952a
00056d f7d1
00056e 0000
00056f 919f
000570 918f
000571 912f
000572 9829
000573 985f
000574 985e
000575 985d
000576 985c
000577 fd03
000578 9a5f
000579 fd02
00057a 9a5e
00057b fd01
00057c 9a5d
00057d fd00
00057e 9a5c
00057f 9a29
000580 932f
000581 938f
000582 939f
000583 e021
000584 e38e
000585 e99c
000586 9701
000587 f7f1
000588 952a
000589 f7d1
00058a 0000
00058b 919f
00058c 918f
00058d 912f
00058e 9829
00058f 985f
000590 985e
000591 985d
000592 985c
000593 910f
000594 914f
000595 911f
000596 910f                      	LCD_send_a_string button1_message1_2
                                 
000597 932f
000598 938f
000599 939f
00059a ef2a
00059b e38e
00059c e99c
00059d 9701
00059e f7f1
00059f 952a
0005a0 f7d1
0005a1 0000
0005a2 919f
0005a3 918f
0005a4 912f                      	delay 2500
0005a5 932f
0005a6 938f
0005a7 939f
0005a8 ef2a
0005a9 e38e
0005aa e99c
0005ab 9701
0005ac f7f1
0005ad 952a
0005ae f7d1
0005af 0000
0005b0 919f
0005b1 918f
0005b2 912f                      	delay 2500
                                 
0005b3 930f
0005b4 e001
0005b5 985f
0005b6 985e
0005b7 985d
0005b8 985c
0005b9 9828
0005ba fd07
0005bb 9a5f
0005bc fd06
0005bd 9a5e
0005be fd05
0005bf 9a5d
0005c0 fd04
0005c1 9a5c
0005c2 9a29
0005c3 932f
0005c4 938f
0005c5 939f
0005c6 e021
0005c7 e38e
0005c8 e99c
0005c9 9701
0005ca f7f1
0005cb 952a
0005cc f7d1
0005cd 0000
0005ce 919f
0005cf 918f
0005d0 912f
0005d1 9829
0005d2 985f
0005d3 985e
0005d4 985d
0005d5 985c
0005d6 fd03
0005d7 9a5f
0005d8 fd02
0005d9 9a5e
0005da fd01
0005db 9a5d
0005dc fd00
0005dd 9a5c
0005de 9a29
0005df 932f
0005e0 938f
0005e1 939f
0005e2 e021
0005e3 e38e
0005e4 e99c
0005e5 9701
0005e6 f7f1
0005e7 952a
0005e8 f7d1
0005e9 0000
0005ea 919f
0005eb 918f
0005ec 912f
0005ed 9829
0005ee 985f
0005ef 985e
0005f0 985d
0005f1 985c
0005f2 910f                      	LCD_send_a_command 0x01  ; clear the LCD
                                 
0005f3 e8e2                      	LDI             ZL, LOW (2 * button1_message2)
0005f4 e1fb                      	LDI             ZH, HIGH (2 * button1_message2)
0005f5 e141                      	LDI             R20, button1_message2_len
                                 
0005f6 930f
0005f7 931f
0005f8 934f
0005f9 9105
0005fa 3040
0005fb f1d9
0005fc 985f
0005fd 985e
0005fe 985d
0005ff 985c
000600 9a28
000601 fd07
000602 9a5f
000603 fd06
000604 9a5e
000605 fd05
000606 9a5d
000607 fd04
000608 9a5c
000609 9a29
00060a 932f
00060b 938f
00060c 939f
00060d e021
00060e e38e
00060f e99c
000610 9701
000611 f7f1
000612 952a
000613 f7d1
000614 0000
000615 919f
000616 918f
000617 912f
000618 9829
000619 985f
00061a 985e
00061b 985d
00061c 985c
00061d fd03
00061e 9a5f
00061f fd02
000620 9a5e
000621 fd01
000622 9a5d
000623 fd00
000624 9a5c
000625 9a29
000626 932f
000627 938f
000628 939f
000629 e021
00062a e38e
00062b e99c
00062c 9701
00062d f7f1
00062e 952a
00062f f7d1
000630 0000
000631 919f
000632 918f
000633 912f
000634 9829
000635 954a
000636 cfc2
000637 930f
000638 e00c
000639 985f
00063a 985e
00063b 985d
00063c 985c
00063d 9828
00063e fd07
00063f 9a5f
000640 fd06
000641 9a5e
000642 fd05
000643 9a5d
000644 fd04
000645 9a5c
000646 9a29
000647 932f
000648 938f
000649 939f
00064a e021
00064b e38e
00064c e99c
00064d 9701
00064e f7f1
00064f 952a
000650 f7d1
000651 0000
000652 919f
000653 918f
000654 912f
000655 9829
000656 985f
000657 985e
000658 985d
000659 985c
00065a fd03
00065b 9a5f
00065c fd02
00065d 9a5e
00065e fd01
00065f 9a5d
000660 fd00
000661 9a5c
000662 9a29
000663 932f
000664 938f
000665 939f
000666 e021
000667 e38e
000668 e99c
000669 9701
00066a f7f1
00066b 952a
00066c f7d1
00066d 0000
00066e 919f
00066f 918f
000670 912f
000671 9829
000672 985f
000673 985e
000674 985d
000675 985c
000676 910f
000677 914f
000678 911f
000679 910f                      	LCD_send_a_string button1_message2
                                 
00067a 930f
00067b ec00
00067c 985f
00067d 985e
00067e 985d
00067f 985c
000680 9828
000681 fd07
000682 9a5f
000683 fd06
000684 9a5e
000685 fd05
000686 9a5d
000687 fd04
000688 9a5c
000689 9a29
00068a 932f
00068b 938f
00068c 939f
00068d e021
00068e e38e
00068f e99c
000690 9701
000691 f7f1
000692 952a
000693 f7d1
000694 0000
000695 919f
000696 918f
000697 912f
000698 9829
000699 985f
00069a 985e
00069b 985d
00069c 985c
00069d fd03
00069e 9a5f
00069f fd02
0006a0 9a5e
0006a1 fd01
0006a2 9a5d
0006a3 fd00
0006a4 9a5c
0006a5 9a29
0006a6 932f
0006a7 938f
0006a8 939f
0006a9 e021
0006aa e38e
0006ab e99c
0006ac 9701
0006ad f7f1
0006ae 952a
0006af f7d1
0006b0 0000
0006b1 919f
0006b2 918f
0006b3 912f
0006b4 9829
0006b5 985f
0006b6 985e
0006b7 985d
0006b8 985c
0006b9 910f                      	LCD_send_a_command 0xC0  ; Set Cursor to second line
                                 
0006ba e9e4                      	LDI             ZL, LOW (2 * button1_message2_2)
0006bb e1fb                      	LDI             ZH, HIGH (2 * button1_message2_2)
0006bc e04f                      	LDI             R20, button1_message2_2_len
                                 
0006bd 930f
0006be 931f
0006bf 934f
0006c0 9105
0006c1 3040
0006c2 f1d9
0006c3 985f
0006c4 985e
0006c5 985d
0006c6 985c
0006c7 9a28
0006c8 fd07
0006c9 9a5f
0006ca fd06
0006cb 9a5e
0006cc fd05
0006cd 9a5d
0006ce fd04
0006cf 9a5c
0006d0 9a29
0006d1 932f
0006d2 938f
0006d3 939f
0006d4 e021
0006d5 e38e
0006d6 e99c
0006d7 9701
0006d8 f7f1
0006d9 952a
0006da f7d1
0006db 0000
0006dc 919f
0006dd 918f
0006de 912f
0006df 9829
0006e0 985f
0006e1 985e
0006e2 985d
0006e3 985c
0006e4 fd03
0006e5 9a5f
0006e6 fd02
0006e7 9a5e
0006e8 fd01
0006e9 9a5d
0006ea fd00
0006eb 9a5c
0006ec 9a29
0006ed 932f
0006ee 938f
0006ef 939f
0006f0 e021
0006f1 e38e
0006f2 e99c
0006f3 9701
0006f4 f7f1
0006f5 952a
0006f6 f7d1
0006f7 0000
0006f8 919f
0006f9 918f
0006fa 912f
0006fb 9829
0006fc 954a
0006fd cfc2
0006fe 930f
0006ff e00c
000700 985f
000701 985e
000702 985d
000703 985c
000704 9828
000705 fd07
000706 9a5f
000707 fd06
000708 9a5e
000709 fd05
00070a 9a5d
00070b fd04
00070c 9a5c
00070d 9a29
00070e 932f
00070f 938f
000710 939f
000711 e021
000712 e38e
000713 e99c
000714 9701
000715 f7f1
000716 952a
000717 f7d1
000718 0000
000719 919f
00071a 918f
00071b 912f
00071c 9829
00071d 985f
00071e 985e
00071f 985d
000720 985c
000721 fd03
000722 9a5f
000723 fd02
000724 9a5e
000725 fd01
000726 9a5d
000727 fd00
000728 9a5c
000729 9a29
00072a 932f
00072b 938f
00072c 939f
00072d e021
00072e e38e
00072f e99c
000730 9701
000731 f7f1
000732 952a
000733 f7d1
000734 0000
000735 919f
000736 918f
000737 912f
000738 9829
000739 985f
00073a 985e
00073b 985d
00073c 985c
00073d 910f
00073e 914f
00073f 911f
000740 910f                      	LCD_send_a_string button1_message2_2
                                 
000741 932f
000742 938f
000743 939f
000744 ef2a
000745 e38e
000746 e99c
000747 9701
000748 f7f1
000749 952a
00074a f7d1
00074b 0000
00074c 919f
00074d 918f
00074e 912f                      	delay 2500
00074f 932f
000750 938f
000751 939f
000752 ef2a
000753 e38e
000754 e99c
000755 9701
000756 f7f1
000757 952a
000758 f7d1
000759 0000
00075a 919f
00075b 918f
00075c 912f                      	delay 2500
                                 
00075d 930f
00075e e001
00075f 985f
000760 985e
000761 985d
000762 985c
000763 9828
000764 fd07
000765 9a5f
000766 fd06
000767 9a5e
000768 fd05
000769 9a5d
00076a fd04
00076b 9a5c
00076c 9a29
00076d 932f
00076e 938f
00076f 939f
000770 e021
000771 e38e
000772 e99c
000773 9701
000774 f7f1
000775 952a
000776 f7d1
000777 0000
000778 919f
000779 918f
00077a 912f
00077b 9829
00077c 985f
00077d 985e
00077e 985d
00077f 985c
000780 fd03
000781 9a5f
000782 fd02
000783 9a5e
000784 fd01
000785 9a5d
000786 fd00
000787 9a5c
000788 9a29
000789 932f
00078a 938f
00078b 939f
00078c e021
00078d e38e
00078e e99c
00078f 9701
000790 f7f1
000791 952a
000792 f7d1
000793 0000
000794 919f
000795 918f
000796 912f
000797 9829
000798 985f
000799 985e
00079a 985d
00079b 985c
00079c 910f                      	LCD_send_a_command 0x01  ; clear the LCD
                                 
00079d eae4                      	LDI             ZL, LOW (2 * button1_message3)
00079e e1fb                      	LDI             ZH, HIGH (2 * button1_message3)
00079f e04b                      	LDI             R20, button1_message3_len
                                 
0007a0 930f
0007a1 931f
0007a2 934f
0007a3 9105
0007a4 3040
0007a5 f1d9
0007a6 985f
0007a7 985e
0007a8 985d
0007a9 985c
0007aa 9a28
0007ab fd07
0007ac 9a5f
0007ad fd06
0007ae 9a5e
0007af fd05
0007b0 9a5d
0007b1 fd04
0007b2 9a5c
0007b3 9a29
0007b4 932f
0007b5 938f
0007b6 939f
0007b7 e021
0007b8 e38e
0007b9 e99c
0007ba 9701
0007bb f7f1
0007bc 952a
0007bd f7d1
0007be 0000
0007bf 919f
0007c0 918f
0007c1 912f
0007c2 9829
0007c3 985f
0007c4 985e
0007c5 985d
0007c6 985c
0007c7 fd03
0007c8 9a5f
0007c9 fd02
0007ca 9a5e
0007cb fd01
0007cc 9a5d
0007cd fd00
0007ce 9a5c
0007cf 9a29
0007d0 932f
0007d1 938f
0007d2 939f
0007d3 e021
0007d4 e38e
0007d5 e99c
0007d6 9701
0007d7 f7f1
0007d8 952a
0007d9 f7d1
0007da 0000
0007db 919f
0007dc 918f
0007dd 912f
0007de 9829
0007df 954a
0007e0 cfc2
0007e1 930f
0007e2 e00c
0007e3 985f
0007e4 985e
0007e5 985d
0007e6 985c
0007e7 9828
0007e8 fd07
0007e9 9a5f
0007ea fd06
0007eb 9a5e
0007ec fd05
0007ed 9a5d
0007ee fd04
0007ef 9a5c
0007f0 9a29
0007f1 932f
0007f2 938f
0007f3 939f
0007f4 e021
0007f5 e38e
0007f6 e99c
0007f7 9701
0007f8 f7f1
0007f9 952a
0007fa f7d1
0007fb 0000
0007fc 919f
0007fd 918f
0007fe 912f
0007ff 9829
000800 985f
000801 985e
000802 985d
000803 985c
000804 fd03
000805 9a5f
000806 fd02
000807 9a5e
000808 fd01
000809 9a5d
00080a fd00
00080b 9a5c
00080c 9a29
00080d 932f
00080e 938f
00080f 939f
000810 e021
000811 e38e
000812 e99c
000813 9701
000814 f7f1
000815 952a
000816 f7d1
000817 0000
000818 919f
000819 918f
00081a 912f
00081b 9829
00081c 985f
00081d 985e
00081e 985d
00081f 985c
000820 910f
000821 914f
000822 911f
000823 910f                      	LCD_send_a_string button1_message3
                                 
000824 930f
000825 ec00
000826 985f
000827 985e
000828 985d
000829 985c
00082a 9828
00082b fd07
00082c 9a5f
00082d fd06
00082e 9a5e
00082f fd05
000830 9a5d
000831 fd04
000832 9a5c
000833 9a29
000834 932f
000835 938f
000836 939f
000837 e021
000838 e38e
000839 e99c
00083a 9701
00083b f7f1
00083c 952a
00083d f7d1
00083e 0000
00083f 919f
000840 918f
000841 912f
000842 9829
000843 985f
000844 985e
000845 985d
000846 985c
000847 fd03
000848 9a5f
000849 fd02
00084a 9a5e
00084b fd01
00084c 9a5d
00084d fd00
00084e 9a5c
00084f 9a29
000850 932f
000851 938f
000852 939f
000853 e021
000854 e38e
000855 e99c
000856 9701
000857 f7f1
000858 952a
000859 f7d1
00085a 0000
00085b 919f
00085c 918f
00085d 912f
00085e 9829
00085f 985f
000860 985e
000861 985d
000862 985c
000863 910f                      	LCD_send_a_command 0xC0  ; Set Cursor to second line
                                 
000864 ebe0                      	LDI             ZL, LOW (2 * button1_message3_2)
000865 e1fb                      	LDI             ZH, HIGH (2 * button1_message3_2)
000866 e04f                      	LDI             R20, button1_message3_2_len
                                 
000867 930f
000868 931f
000869 934f
00086a 9105
00086b 3040
00086c f1d9
00086d 985f
00086e 985e
00086f 985d
000870 985c
000871 9a28
000872 fd07
000873 9a5f
000874 fd06
000875 9a5e
000876 fd05
000877 9a5d
000878 fd04
000879 9a5c
00087a 9a29
00087b 932f
00087c 938f
00087d 939f
00087e e021
00087f e38e
000880 e99c
000881 9701
000882 f7f1
000883 952a
000884 f7d1
000885 0000
000886 919f
000887 918f
000888 912f
000889 9829
00088a 985f
00088b 985e
00088c 985d
00088d 985c
00088e fd03
00088f 9a5f
000890 fd02
000891 9a5e
000892 fd01
000893 9a5d
000894 fd00
000895 9a5c
000896 9a29
000897 932f
000898 938f
000899 939f
00089a e021
00089b e38e
00089c e99c
00089d 9701
00089e f7f1
00089f 952a
0008a0 f7d1
0008a1 0000
0008a2 919f
0008a3 918f
0008a4 912f
0008a5 9829
0008a6 954a
0008a7 cfc2
0008a8 930f
0008a9 e00c
0008aa 985f
0008ab 985e
0008ac 985d
0008ad 985c
0008ae 9828
0008af fd07
0008b0 9a5f
0008b1 fd06
0008b2 9a5e
0008b3 fd05
0008b4 9a5d
0008b5 fd04
0008b6 9a5c
0008b7 9a29
0008b8 932f
0008b9 938f
0008ba 939f
0008bb e021
0008bc e38e
0008bd e99c
0008be 9701
0008bf f7f1
0008c0 952a
0008c1 f7d1
0008c2 0000
0008c3 919f
0008c4 918f
0008c5 912f
0008c6 9829
0008c7 985f
0008c8 985e
0008c9 985d
0008ca 985c
0008cb fd03
0008cc 9a5f
0008cd fd02
0008ce 9a5e
0008cf fd01
0008d0 9a5d
0008d1 fd00
0008d2 9a5c
0008d3 9a29
0008d4 932f
0008d5 938f
0008d6 939f
0008d7 e021
0008d8 e38e
0008d9 e99c
0008da 9701
0008db f7f1
0008dc 952a
0008dd f7d1
0008de 0000
0008df 919f
0008e0 918f
0008e1 912f
0008e2 9829
0008e3 985f
0008e4 985e
0008e5 985d
0008e6 985c
0008e7 910f
0008e8 914f
0008e9 911f
0008ea 910f                      	LCD_send_a_string button1_message3_2
                                 
0008eb 932f
0008ec 938f
0008ed 939f
0008ee ef2a
0008ef e38e
0008f0 e99c
0008f1 9701
0008f2 f7f1
0008f3 952a
0008f4 f7d1
0008f5 0000
0008f6 919f
0008f7 918f
0008f8 912f                      	delay 2500
0008f9 932f
0008fa 938f
0008fb 939f
0008fc ef2a
0008fd e38e
0008fe e99c
0008ff 9701
000900 f7f1
000901 952a
000902 f7d1
000903 0000
000904 919f
000905 918f
000906 912f                      	delay 2500
                                 
000907 930f
000908 e001
000909 985f
00090a 985e
00090b 985d
00090c 985c
00090d 9828
00090e fd07
00090f 9a5f
000910 fd06
000911 9a5e
000912 fd05
000913 9a5d
000914 fd04
000915 9a5c
000916 9a29
000917 932f
000918 938f
000919 939f
00091a e021
00091b e38e
00091c e99c
00091d 9701
00091e f7f1
00091f 952a
000920 f7d1
000921 0000
000922 919f
000923 918f
000924 912f
000925 9829
000926 985f
000927 985e
000928 985d
000929 985c
00092a fd03
00092b 9a5f
00092c fd02
00092d 9a5e
00092e fd01
00092f 9a5d
000930 fd00
000931 9a5c
000932 9a29
000933 932f
000934 938f
000935 939f
000936 e021
000937 e38e
000938 e99c
000939 9701
00093a f7f1
00093b 952a
00093c f7d1
00093d 0000
00093e 919f
00093f 918f
000940 912f
000941 9829
000942 985f
000943 985e
000944 985d
000945 985c
000946 910f                      	LCD_send_a_command 0x01  ; clear the LCD
                                 
000947 ece0                      	LDI             ZL, LOW (2 * button1_message4)
000948 e1fb                      	LDI             ZH, HIGH (2 * button1_message4)
000949 e04f                      	LDI             R20, button1_message4_len
                                 
00094a 930f
00094b 931f
00094c 934f
00094d 9105
00094e 3040
00094f f1d9
000950 985f
000951 985e
000952 985d
000953 985c
000954 9a28
000955 fd07
000956 9a5f
000957 fd06
000958 9a5e
000959 fd05
00095a 9a5d
00095b fd04
00095c 9a5c
00095d 9a29
00095e 932f
00095f 938f
000960 939f
000961 e021
000962 e38e
000963 e99c
000964 9701
000965 f7f1
000966 952a
000967 f7d1
000968 0000
000969 919f
00096a 918f
00096b 912f
00096c 9829
00096d 985f
00096e 985e
00096f 985d
000970 985c
000971 fd03
000972 9a5f
000973 fd02
000974 9a5e
000975 fd01
000976 9a5d
000977 fd00
000978 9a5c
000979 9a29
00097a 932f
00097b 938f
00097c 939f
00097d e021
00097e e38e
00097f e99c
000980 9701
000981 f7f1
000982 952a
000983 f7d1
000984 0000
000985 919f
000986 918f
000987 912f
000988 9829
000989 954a
00098a cfc2
00098b 930f
00098c e00c
00098d 985f
00098e 985e
00098f 985d
000990 985c
000991 9828
000992 fd07
000993 9a5f
000994 fd06
000995 9a5e
000996 fd05
000997 9a5d
000998 fd04
000999 9a5c
00099a 9a29
00099b 932f
00099c 938f
00099d 939f
00099e e021
00099f e38e
0009a0 e99c
0009a1 9701
0009a2 f7f1
0009a3 952a
0009a4 f7d1
0009a5 0000
0009a6 919f
0009a7 918f
0009a8 912f
0009a9 9829
0009aa 985f
0009ab 985e
0009ac 985d
0009ad 985c
0009ae fd03
0009af 9a5f
0009b0 fd02
0009b1 9a5e
0009b2 fd01
0009b3 9a5d
0009b4 fd00
0009b5 9a5c
0009b6 9a29
0009b7 932f
0009b8 938f
0009b9 939f
0009ba e021
0009bb e38e
0009bc e99c
0009bd 9701
0009be f7f1
0009bf 952a
0009c0 f7d1
0009c1 0000
0009c2 919f
0009c3 918f
0009c4 912f
0009c5 9829
0009c6 985f
0009c7 985e
0009c8 985d
0009c9 985c
0009ca 910f
0009cb 914f
0009cc 911f
0009cd 910f                      	LCD_send_a_string button1_message4
                                 
0009ce 930f
0009cf ec00
0009d0 985f
0009d1 985e
0009d2 985d
0009d3 985c
0009d4 9828
0009d5 fd07
0009d6 9a5f
0009d7 fd06
0009d8 9a5e
0009d9 fd05
0009da 9a5d
0009db fd04
0009dc 9a5c
0009dd 9a29
0009de 932f
0009df 938f
0009e0 939f
0009e1 e021
0009e2 e38e
0009e3 e99c
0009e4 9701
0009e5 f7f1
0009e6 952a
0009e7 f7d1
0009e8 0000
0009e9 919f
0009ea 918f
0009eb 912f
0009ec 9829
0009ed 985f
0009ee 985e
0009ef 985d
0009f0 985c
0009f1 fd03
0009f2 9a5f
0009f3 fd02
0009f4 9a5e
0009f5 fd01
0009f6 9a5d
0009f7 fd00
0009f8 9a5c
0009f9 9a29
0009fa 932f
0009fb 938f
0009fc 939f
0009fd e021
0009fe e38e
0009ff e99c
000a00 9701
000a01 f7f1
000a02 952a
000a03 f7d1
000a04 0000
000a05 919f
000a06 918f
000a07 912f
000a08 9829
000a09 985f
000a0a 985e
000a0b 985d
000a0c 985c
000a0d 910f                      	LCD_send_a_command 0xC0  ; Set Cursor to second line
                                 
000a0e ede0                      	LDI             ZL, LOW (2 * button1_message4_2)
000a0f e1fb                      	LDI             ZH, HIGH (2 * button1_message4_2)
000a10 e04f                      	LDI             R20, button1_message4_2_len
                                 
000a11 930f
000a12 931f
000a13 934f
000a14 9105
000a15 3040
000a16 f1d9
000a17 985f
000a18 985e
000a19 985d
000a1a 985c
000a1b 9a28
000a1c fd07
000a1d 9a5f
000a1e fd06
000a1f 9a5e
000a20 fd05
000a21 9a5d
000a22 fd04
000a23 9a5c
000a24 9a29
000a25 932f
000a26 938f
000a27 939f
000a28 e021
000a29 e38e
000a2a e99c
000a2b 9701
000a2c f7f1
000a2d 952a
000a2e f7d1
000a2f 0000
000a30 919f
000a31 918f
000a32 912f
000a33 9829
000a34 985f
000a35 985e
000a36 985d
000a37 985c
000a38 fd03
000a39 9a5f
000a3a fd02
000a3b 9a5e
000a3c fd01
000a3d 9a5d
000a3e fd00
000a3f 9a5c
000a40 9a29
000a41 932f
000a42 938f
000a43 939f
000a44 e021
000a45 e38e
000a46 e99c
000a47 9701
000a48 f7f1
000a49 952a
000a4a f7d1
000a4b 0000
000a4c 919f
000a4d 918f
000a4e 912f
000a4f 9829
000a50 954a
000a51 cfc2
000a52 930f
000a53 e00c
000a54 985f
000a55 985e
000a56 985d
000a57 985c
000a58 9828
000a59 fd07
000a5a 9a5f
000a5b fd06
000a5c 9a5e
000a5d fd05
000a5e 9a5d
000a5f fd04
000a60 9a5c
000a61 9a29
000a62 932f
000a63 938f
000a64 939f
000a65 e021
000a66 e38e
000a67 e99c
000a68 9701
000a69 f7f1
000a6a 952a
000a6b f7d1
000a6c 0000
000a6d 919f
000a6e 918f
000a6f 912f
000a70 9829
000a71 985f
000a72 985e
000a73 985d
000a74 985c
000a75 fd03
000a76 9a5f
000a77 fd02
000a78 9a5e
000a79 fd01
000a7a 9a5d
000a7b fd00
000a7c 9a5c
000a7d 9a29
000a7e 932f
000a7f 938f
000a80 939f
000a81 e021
000a82 e38e
000a83 e99c
000a84 9701
000a85 f7f1
000a86 952a
000a87 f7d1
000a88 0000
000a89 919f
000a8a 918f
000a8b 912f
000a8c 9829
000a8d 985f
000a8e 985e
000a8f 985d
000a90 985c
000a91 910f
000a92 914f
000a93 911f
000a94 910f                      	LCD_send_a_string button1_message4_2
                                 
000a95 932f
000a96 938f
000a97 939f
000a98 ef2a
000a99 e38e
000a9a e99c
000a9b 9701
000a9c f7f1
000a9d 952a
000a9e f7d1
000a9f 0000
000aa0 919f
000aa1 918f
000aa2 912f                      	delay 2500
000aa3 932f
000aa4 938f
000aa5 939f
000aa6 ef2a
000aa7 e38e
000aa8 e99c
000aa9 9701
000aaa f7f1
000aab 952a
000aac f7d1
000aad 0000
000aae 919f
000aaf 918f
000ab0 912f                      	delay 2500
                                 
000ab1 9508                      	ret
                                 
                                  button2_functionality:
000ab2 930f
000ab3 e001
000ab4 985f
000ab5 985e
000ab6 985d
000ab7 985c
000ab8 9828
000ab9 fd07
000aba 9a5f
000abb fd06
000abc 9a5e
000abd fd05
000abe 9a5d
000abf fd04
000ac0 9a5c
000ac1 9a29
000ac2 932f
000ac3 938f
000ac4 939f
000ac5 e021
000ac6 e38e
000ac7 e99c
000ac8 9701
000ac9 f7f1
000aca 952a
000acb f7d1
000acc 0000
000acd 919f
000ace 918f
000acf 912f
000ad0 9829
000ad1 985f
000ad2 985e
000ad3 985d
000ad4 985c
000ad5 fd03
000ad6 9a5f
000ad7 fd02
000ad8 9a5e
000ad9 fd01
000ada 9a5d
000adb fd00
000adc 9a5c
000add 9a29
000ade 932f
000adf 938f
000ae0 939f
000ae1 e021
000ae2 e38e
000ae3 e99c
000ae4 9701
000ae5 f7f1
000ae6 952a
000ae7 f7d1
000ae8 0000
000ae9 919f
000aea 918f
000aeb 912f
000aec 9829
000aed 985f
000aee 985e
000aef 985d
000af0 985c
000af1 910f                      	LCD_send_a_command 0x01  ; clear the LCD
000af2 e390                      	ldi r25,'0'
000af3 9508                      	ret
                                 
                                  button3_functionality:
000af4 eee0                      	LDI             ZL, LOW (2 * button3_message1)
000af5 e1fb                      	LDI             ZH, HIGH (2 * button3_message1)
000af6 e141                      	LDI             R20, button3_message1_len
                                 
000af7 930f
000af8 931f
000af9 934f
000afa 9105
000afb 3040
000afc f1d9
000afd 985f
000afe 985e
000aff 985d
000b00 985c
000b01 9a28
000b02 fd07
000b03 9a5f
000b04 fd06
000b05 9a5e
000b06 fd05
000b07 9a5d
000b08 fd04
000b09 9a5c
000b0a 9a29
000b0b 932f
000b0c 938f
000b0d 939f
000b0e e021
000b0f e38e
000b10 e99c
000b11 9701
000b12 f7f1
000b13 952a
000b14 f7d1
000b15 0000
000b16 919f
000b17 918f
000b18 912f
000b19 9829
000b1a 985f
000b1b 985e
000b1c 985d
000b1d 985c
000b1e fd03
000b1f 9a5f
000b20 fd02
000b21 9a5e
000b22 fd01
000b23 9a5d
000b24 fd00
000b25 9a5c
000b26 9a29
000b27 932f
000b28 938f
000b29 939f
000b2a e021
000b2b e38e
000b2c e99c
000b2d 9701
000b2e f7f1
000b2f 952a
000b30 f7d1
000b31 0000
000b32 919f
000b33 918f
000b34 912f
000b35 9829
000b36 954a
000b37 cfc2
000b38 930f
000b39 e00c
000b3a 985f
000b3b 985e
000b3c 985d
000b3d 985c
000b3e 9828
000b3f fd07
000b40 9a5f
000b41 fd06
000b42 9a5e
000b43 fd05
000b44 9a5d
000b45 fd04
000b46 9a5c
000b47 9a29
000b48 932f
000b49 938f
000b4a 939f
000b4b e021
000b4c e38e
000b4d e99c
000b4e 9701
000b4f f7f1
000b50 952a
000b51 f7d1
000b52 0000
000b53 919f
000b54 918f
000b55 912f
000b56 9829
000b57 985f
000b58 985e
000b59 985d
000b5a 985c
000b5b fd03
000b5c 9a5f
000b5d fd02
000b5e 9a5e
000b5f fd01
000b60 9a5d
000b61 fd00
000b62 9a5c
000b63 9a29
000b64 932f
000b65 938f
000b66 939f
000b67 e021
000b68 e38e
000b69 e99c
000b6a 9701
000b6b f7f1
000b6c 952a
000b6d f7d1
000b6e 0000
000b6f 919f
000b70 918f
000b71 912f
000b72 9829
000b73 985f
000b74 985e
000b75 985d
000b76 985c
000b77 910f
000b78 914f
000b79 911f
000b7a 910f                      	LCD_send_a_string button3_message1
                                 	
000b7b 930f
000b7c ec00
000b7d 985f
000b7e 985e
000b7f 985d
000b80 985c
000b81 9828
000b82 fd07
000b83 9a5f
000b84 fd06
000b85 9a5e
000b86 fd05
000b87 9a5d
000b88 fd04
000b89 9a5c
000b8a 9a29
000b8b 932f
000b8c 938f
000b8d 939f
000b8e e021
000b8f e38e
000b90 e99c
000b91 9701
000b92 f7f1
000b93 952a
000b94 f7d1
000b95 0000
000b96 919f
000b97 918f
000b98 912f
000b99 9829
000b9a 985f
000b9b 985e
000b9c 985d
000b9d 985c
000b9e fd03
000b9f 9a5f
000ba0 fd02
000ba1 9a5e
000ba2 fd01
000ba3 9a5d
000ba4 fd00
000ba5 9a5c
000ba6 9a29
000ba7 932f
000ba8 938f
000ba9 939f
000baa e021
000bab e38e
000bac e99c
000bad 9701
000bae f7f1
000baf 952a
000bb0 f7d1
000bb1 0000
000bb2 919f
000bb3 918f
000bb4 912f
000bb5 9829
000bb6 985f
000bb7 985e
000bb8 985d
000bb9 985c
000bba 910f                      	LCD_send_a_command 0xC0  ; move cursor to the second line 
                                 
000bbb efe2                      	LDI             ZL, LOW (2 * button3_message2)
000bbc e1fb                      	LDI             ZH, HIGH (2 * button3_message2)
000bbd e141                      	LDI             R20, button3_message2_len
                                 
000bbe 930f
000bbf 931f
000bc0 934f
000bc1 9105
000bc2 3040
000bc3 f1d9
000bc4 985f
000bc5 985e
000bc6 985d
000bc7 985c
000bc8 9a28
000bc9 fd07
000bca 9a5f
000bcb fd06
000bcc 9a5e
000bcd fd05
000bce 9a5d
000bcf fd04
000bd0 9a5c
000bd1 9a29
000bd2 932f
000bd3 938f
000bd4 939f
000bd5 e021
000bd6 e38e
000bd7 e99c
000bd8 9701
000bd9 f7f1
000bda 952a
000bdb f7d1
000bdc 0000
000bdd 919f
000bde 918f
000bdf 912f
000be0 9829
000be1 985f
000be2 985e
000be3 985d
000be4 985c
000be5 fd03
000be6 9a5f
000be7 fd02
000be8 9a5e
000be9 fd01
000bea 9a5d
000beb fd00
000bec 9a5c
000bed 9a29
000bee 932f
000bef 938f
000bf0 939f
000bf1 e021
000bf2 e38e
000bf3 e99c
000bf4 9701
000bf5 f7f1
000bf6 952a
000bf7 f7d1
000bf8 0000
000bf9 919f
000bfa 918f
000bfb 912f
000bfc 9829
000bfd 954a
000bfe cfc2
000bff 930f
000c00 e00c
000c01 985f
000c02 985e
000c03 985d
000c04 985c
000c05 9828
000c06 fd07
000c07 9a5f
000c08 fd06
000c09 9a5e
000c0a fd05
000c0b 9a5d
000c0c fd04
000c0d 9a5c
000c0e 9a29
000c0f 932f
000c10 938f
000c11 939f
000c12 e021
000c13 e38e
000c14 e99c
000c15 9701
000c16 f7f1
000c17 952a
000c18 f7d1
000c19 0000
000c1a 919f
000c1b 918f
000c1c 912f
000c1d 9829
000c1e 985f
000c1f 985e
000c20 985d
000c21 985c
000c22 fd03
000c23 9a5f
000c24 fd02
000c25 9a5e
000c26 fd01
000c27 9a5d
000c28 fd00
000c29 9a5c
000c2a 9a29
000c2b 932f
000c2c 938f
000c2d 939f
000c2e e021
000c2f e38e
000c30 e99c
000c31 9701
000c32 f7f1
000c33 952a
000c34 f7d1
000c35 0000
000c36 919f
000c37 918f
000c38 912f
000c39 9829
000c3a 985f
000c3b 985e
000c3c 985d
000c3d 985c
000c3e 910f
000c3f 914f
000c40 911f
000c41 910f                      	LCD_send_a_string button3_message2
                                 
000c42 932f
000c43 938f
000c44 939f
000c45 e02f
000c46 e38e
000c47 e99c
000c48 9701
000c49 f7f1
000c4a 952a
000c4b f7d1
000c4c 0000
000c4d 919f
000c4e 918f
000c4f 912f                      	delay 150
                                 
000c50 9508                      	ret
                                 
                                 button4_functionality_on:
000c51 9a2d                      	sbi PORTB,PB5  ; on the LCD
000c52 e390                      	ldi r25,'0'
000c53 9508                      	ret
                                 
                                 button4_functionality_off:
000c54 982d                      	cbi PORTB,PB5  ; off the LCD
000c55 e390                      	ldi r25,'0'
000c56 9508                      	ret
                                 
                                 button5_functionality:
000c57 930f
000c58 e001
000c59 985f
000c5a 985e
000c5b 985d
000c5c 985c
000c5d 9828
000c5e fd07
000c5f 9a5f
000c60 fd06
000c61 9a5e
000c62 fd05
000c63 9a5d
000c64 fd04
000c65 9a5c
000c66 9a29
000c67 932f
000c68 938f
000c69 939f
000c6a e021
000c6b e38e
000c6c e99c
000c6d 9701
000c6e f7f1
000c6f 952a
000c70 f7d1
000c71 0000
000c72 919f
000c73 918f
000c74 912f
000c75 9829
000c76 985f
000c77 985e
000c78 985d
000c79 985c
000c7a fd03
000c7b 9a5f
000c7c fd02
000c7d 9a5e
000c7e fd01
000c7f 9a5d
000c80 fd00
000c81 9a5c
000c82 9a29
000c83 932f
000c84 938f
000c85 939f
000c86 e021
000c87 e38e
000c88 e99c
000c89 9701
000c8a f7f1
000c8b 952a
000c8c f7d1
000c8d 0000
000c8e 919f
000c8f 918f
000c90 912f
000c91 9829
000c92 985f
000c93 985e
000c94 985d
000c95 985c
000c96 910f                      	LCD_send_a_command 0x01  ; clear the LCD
000c97 930f
000c98 e800
000c99 985f
000c9a 985e
000c9b 985d
000c9c 985c
000c9d 9828
000c9e fd07
000c9f 9a5f
000ca0 fd06
000ca1 9a5e
000ca2 fd05
000ca3 9a5d
000ca4 fd04
000ca5 9a5c
000ca6 9a29
000ca7 932f
000ca8 938f
000ca9 939f
000caa e021
000cab e38e
000cac e99c
000cad 9701
000cae f7f1
000caf 952a
000cb0 f7d1
000cb1 0000
000cb2 919f
000cb3 918f
000cb4 912f
000cb5 9829
000cb6 985f
000cb7 985e
000cb8 985d
000cb9 985c
000cba fd03
000cbb 9a5f
000cbc fd02
000cbd 9a5e
000cbe fd01
000cbf 9a5d
000cc0 fd00
000cc1 9a5c
000cc2 9a29
000cc3 932f
000cc4 938f
000cc5 939f
000cc6 e021
000cc7 e38e
000cc8 e99c
000cc9 9701
000cca f7f1
000ccb 952a
000ccc f7d1
000ccd 0000
000cce 919f
000ccf 918f
000cd0 912f
000cd1 9829
000cd2 985f
000cd3 985e
000cd4 985d
000cd5 985c
000cd6 910f                      	LCD_send_a_command 0x80    ;set the cursor to the begining of the new line 
                                 
000cd7 e050                      	ldi r21,0
                                 	myloop:
000cd8 1756                      		cp r21,r22
000cd9 f409                      		brne newmesg
000cda c042                      		rjmp exit_loop
                                 		newmesg:
000cdb 930f
000cdc e104
000cdd 985f
000cde 985e
000cdf 985d
000ce0 985c
000ce1 9828
000ce2 fd07
000ce3 9a5f
000ce4 fd06
000ce5 9a5e
000ce6 fd05
000ce7 9a5d
000ce8 fd04
000ce9 9a5c
000cea 9a29
000ceb 932f
000cec 938f
000ced 939f
000cee e021
000cef e38e
000cf0 e99c
000cf1 9701
000cf2 f7f1
000cf3 952a
000cf4 f7d1
000cf5 0000
000cf6 919f
000cf7 918f
000cf8 912f
000cf9 9829
000cfa 985f
000cfb 985e
000cfc 985d
000cfd 985c
000cfe fd03
000cff 9a5f
000d00 fd02
000d01 9a5e
000d02 fd01
000d03 9a5d
000d04 fd00
000d05 9a5c
000d06 9a29
000d07 932f
000d08 938f
000d09 939f
000d0a e021
000d0b e38e
000d0c e99c
000d0d 9701
000d0e f7f1
000d0f 952a
000d10 f7d1
000d11 0000
000d12 919f
000d13 918f
000d14 912f
000d15 9829
000d16 985f
000d17 985e
000d18 985d
000d19 985c
000d1a 910f                      		LCD_send_a_command 0x14  ; Increment cursor to right on the LCD
000d1b 9553                      		inc r21
000d1c cfbb                      	rjmp myloop
                                 
                                 	exit_loop :
                                 
000d1d e0e4                      	LDI             ZL, LOW (2 * name)
000d1e e1fc                      	LDI             ZH, HIGH (2 * name)
000d1f e049                      	LDI             R20, name_len
                                 
000d20 930f
000d21 931f
000d22 934f
000d23 9105
000d24 3040
000d25 f1d9
000d26 985f
000d27 985e
000d28 985d
000d29 985c
000d2a 9a28
000d2b fd07
000d2c 9a5f
000d2d fd06
000d2e 9a5e
000d2f fd05
000d30 9a5d
000d31 fd04
000d32 9a5c
000d33 9a29
000d34 932f
000d35 938f
000d36 939f
000d37 e021
000d38 e38e
000d39 e99c
000d3a 9701
000d3b f7f1
000d3c 952a
000d3d f7d1
000d3e 0000
000d3f 919f
000d40 918f
000d41 912f
000d42 9829
000d43 985f
000d44 985e
000d45 985d
000d46 985c
000d47 fd03
000d48 9a5f
000d49 fd02
000d4a 9a5e
000d4b fd01
000d4c 9a5d
000d4d fd00
000d4e 9a5c
000d4f 9a29
000d50 932f
000d51 938f
000d52 939f
000d53 e021
000d54 e38e
000d55 e99c
000d56 9701
000d57 f7f1
000d58 952a
000d59 f7d1
000d5a 0000
000d5b 919f
000d5c 918f
000d5d 912f
000d5e 9829
000d5f 954a
000d60 cfc2
000d61 930f
000d62 e00c
000d63 985f
000d64 985e
000d65 985d
000d66 985c
000d67 9828
000d68 fd07
000d69 9a5f
000d6a fd06
000d6b 9a5e
000d6c fd05
000d6d 9a5d
000d6e fd04
000d6f 9a5c
000d70 9a29
000d71 932f
000d72 938f
000d73 939f
000d74 e021
000d75 e38e
000d76 e99c
000d77 9701
000d78 f7f1
000d79 952a
000d7a f7d1
000d7b 0000
000d7c 919f
000d7d 918f
000d7e 912f
000d7f 9829
000d80 985f
000d81 985e
000d82 985d
000d83 985c
000d84 fd03
000d85 9a5f
000d86 fd02
000d87 9a5e
000d88 fd01
000d89 9a5d
000d8a fd00
000d8b 9a5c
000d8c 9a29
000d8d 932f
000d8e 938f
000d8f 939f
000d90 e021
000d91 e38e
000d92 e99c
000d93 9701
000d94 f7f1
000d95 952a
000d96 f7d1
000d97 0000
000d98 919f
000d99 918f
000d9a 912f
000d9b 9829
000d9c 985f
000d9d 985e
000d9e 985d
000d9f 985c
000da0 910f
000da1 914f
000da2 911f
000da3 910f                      	LCD_send_a_string name
                                 
000da4 932f
000da5 938f
000da6 939f
000da7 e12e
000da8 e38e
000da9 e99c
000daa 9701
000dab f7f1
000dac 952a
000dad f7d1
000dae 0000
000daf 919f
000db0 918f
000db1 912f                      	delay 300
                                 
000db2 9508                      	ret
                                 
                                 	
000db3 2020
000db4 5247
000db5 4545
000db6 4954
000db7 474e
000db8 5420
000db9 004f                      button1_message1 :	.db	"  GREETING TO",0
                                 len1: .equ	button1_message1_len = (2 * (len1 - button1_message1))-1
                                 
000dba 2020
000dbb 4520
000dbc 4556
000dbd 5952
000dbe 4e4f
000dbf 2045
000dc0 0021                      button1_message1_2 :	.db	"   EVERYONE !",0
                                 len7: .equ	button1_message1_2_len = (2 * (len7 - button1_message1_2))-1
                                 
000dc1 4f43
000dc2 4c41
000dc3 4c20
000dc4 4241
000dc5 5020
000dc6 4f52
000dc7 454a
000dc8 5443
D:\AssemblerApplication1\AssemblerApplication1\main.asm(258): warning: .cseg .db misalignment - padding zero byte
000dc9 0000                      button1_message2 :	.db	"COAL LAB PROJECT",0
                                 len2 : .equ	button1_message2_len = (2 * (len2 - button1_message2))-1
                                 
000dca 2020
000dcb 5320
000dcc 5345
000dcd 4953
000dce 4e4f
000dcf 3220
000dd0 3230
000dd1 0032                      button1_message2_2 :	.db	"   SESSION 2022",0
                                 len8 : .equ	button1_message2_2_len = (2 * (len8 - button1_message2_2))-1
                                 
000dd2 5250
000dd3 5045
000dd4 5241
000dd5 4445
000dd6 4220
000dd7 0059                      button1_message3 :	.db	"PREPARED BY",0
                                 len3 : .equ	button1_message3_len = (2 * (len3 - button1_message3))-1
                                 
000dd8 3331
000dd9 2033
000dda 3431
000ddb 2037
000ddc 3331
000ddd 2037
000dde 3531
D:\AssemblerApplication1\AssemblerApplication1\main.asm(267): warning: .cseg .db misalignment - padding zero byte
000ddf 0036                      button1_message3_2 :	.db	"133 147 137 156"
                                 len9 : .equ	button1_message3_2_len = (2 * (len9 - button1_message3_2))-1
                                 
000de0 4154
000de1 5959
000de2 4241
000de3 2020
000de4 4d55
000de5 4941
000de6 414d
D:\AssemblerApplication1\AssemblerApplication1\main.asm(270): warning: .cseg .db misalignment - padding zero byte
000de7 0000                      button1_message4 :	.db	"TAYYAB  UMAIMA",0
                                 len4 : .equ	button1_message4_len = (2 * (len4 - button1_message4))-1
                                 
000de8 4f4d
000de9 494d
000dea 414e
000deb 2020
000dec 4847
000ded 4e41
000dee 4149
D:\AssemblerApplication1\AssemblerApplication1\main.asm(273): warning: .cseg .db misalignment - padding zero byte
000def 0000                      button1_message4_2 :	.db	"MOMINA  GHANIA",0
                                 len10 : .equ	button1_message4_2_len = (2 * (len10 - button1_message4_2))-1
                                 
000df0 2020
000df1 5641
000df2 2052
000df3 5341
000df4 4553
000df5 424d
000df6 594c
000df7 2020
D:\AssemblerApplication1\AssemblerApplication1\main.asm(276): warning: .cseg .db misalignment - padding zero byte
000df8 0000                      button3_message1 :	.db	"  AVR ASSEMBLY  ",0
                                 len5 : .equ	button3_message1_len = (2 * (len5 - button3_message1))-1
                                 
000df9 4220
000dfa 2059
000dfb 4953
000dfc 2e52
000dfd 5420
000dfe 4845
000dff 4553
000e00 4e45
D:\AssemblerApplication1\AssemblerApplication1\main.asm(279): warning: .cseg .db misalignment - padding zero byte
000e01 0000                      button3_message2 :	.db	" BY SIR. TEHSEEN",0
                                 len6 : .equ	button3_message2_len = (2 * (len6 - button3_message2))-1
                                 
000e02 6544
000e03 6576
000e04 6f6c
000e05 6570
000e06 0072                      name :	.db	"Developer",0
                                 len11 : .equ	name_len = (2 * (len11 - name))-1
                                 
                                 ; Interrupt PCINT0 ISR function


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
x  :   0 y  :   0 z  :  11 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:  20 r16: 536 r17:  41 r18: 455 r19:   5 r20:  55 
r21:   5 r22:   5 r23:   0 r24: 438 r25: 338 r26:   0 r27:   0 r28:   6 
r29:   6 r30:  17 r31:  11 
Registers used: 15 out of 35 (42.9%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   6 adiw  :   0 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   3 brcs  :   0 break :   0 breq  :  21 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   0 brmi  :   0 
brne  : 222 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   5 cbi   : 638 cbr   :   0 
clc   :   3 clh   :   0 cli   :   0 cln   :   0 clr   :   0 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   1 cpc   :   0 
cpi   :  23 cpse  :   0 dec   : 123 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   0 inc   :   3 jmp   :   1 
ld    :   0 ldd   :   0 ldi   : 421 lds   :   4 lpm   :  11 lsl   :   0 
lsr   :   0 mov   :   9 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   0 nop   : 110 or    :   0 ori   :   0 out   :   2 pop   : 408 
push  : 408 rcall :   0 ret   :   6 reti  :   1 rjmp  :  43 rol   :   6 
ror   :   0 sbc   :   0 sbci  :   0 sbi   : 482 sbic  :   0 sbis  :   0 
sbiw  : 109 sbr   :   0 sbrc  : 368 sbrs  :   2 sec   :   3 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 sts   :   6 
sub   :   6 subi  :   0 swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 33 out of 113 (29.2%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x001c0e   6946    168   7114   32768  21.7%
[.dseg] 0x000100 0x000100      0      0      0    2048   0.0%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 6 warnings
